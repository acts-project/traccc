/** TRACCC library, part of the ACTS project (R&D line)
 *
 * (c) 2022 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

// SYCL library include(s).
#include "../utils/get_queue.hpp"
#include "traccc/sycl/clusterization/measurement_creation.hpp"

// SYCL include(s).
#include <CL/sycl.hpp>

// Vecmem include(s).
#include <vecmem/utils/sycl/copy.hpp>

namespace traccc::sycl {

measurement_creation::measurement_creation(vecmem::memory_resource &mr,
                                           queue_wrapper queue)
    : m_mr(mr), m_queue(queue) {}

host_measurement_container measurement_creation::operator()(
    const host_cluster_container &c,
    const host_cell_module_collection &l) const {
    output_type measurements(&m_mr.get());
    this->operator()(c, l, measurements);
    return measurements;
}

void measurement_creation::operator()(
    const host_cluster_container &clusters,
    const host_cell_module_collection &cell_modules_per_event,
    output_type &measurements) const {

    vecmem::sycl::copy copy{m_queue.queue()};
    unsigned int size_buf = cell_modules_per_event.size();

    // Retrieve the number of clusters per each module
    // NOTE: the +1 comes from a crash while running the code on the
    // CUDA backend In that case, the jagged vector buffer used for
    // measurments seems not to have enough capacity which seems wrong
    // because the number of measurments per module (the inner vector)
    // cannot exceed the number of clusters per module
    std::vector<std::size_t> cluster_sizes(cell_modules_per_event.size(), 1);
    for (const auto &cl_id : clusters.get_headers()) {
        cluster_sizes.at(cl_id.module_idx)++;
    }

    // Resizable buffer for the measurements
    measurement_container_buffer measurement_buffer{
        {size_buf, m_mr.get()},
        {std::vector<std::size_t>(cluster_sizes.size(), 0), cluster_sizes,
         m_mr.get()}};
    copy.setup(measurement_buffer.items);

    // Vector views to move data to the device
    auto clusters_data = get_data(clusters, &m_mr.get());
    cluster_container_const_view clusters_view(clusters_data);
    measurement_container_view measurement_view(measurement_buffer);

    // range of kernel execution
    auto range = clusters.size();

    // Run the kernel
    details::get_queue(m_queue)
        .parallel_for(
            range,
            [clusters_view, measurement_view](auto idx) {
                // Initialize device vectors
                device_cluster_const_container clusters_device(clusters_view);
                device_measurement_container measurement_device(
                    measurement_view);

                // Ignore if idx is out of range
                if (idx >= clusters_device.size())
                    return;

                // items: cluster of cells at current idx
                // header: cluster_id object with the information about the cell
                // module
                const device_cell_const_collection &cluster =
                    clusters_device.get_items().at(idx);
                const cluster_id &cl_id = clusters_device.get_headers().at(idx);

                const vector2 pitch = get_pitch(cl_id);
                const auto module_idx = cl_id.module_idx;

                scalar totalWeight = 0.;

                // To calculate the mean and variance with high numerical
                // stability we use a weighted variant of Welford's algorithm.
                // This is a single-pass online algorithm that works well for
                // large numbers of samples, as well as samples with very high
                // values.
                //
                // To learn more about this algorithm please refer to:
                // [1] https://doi.org/10.1080/00401706.1962.10490022
                // [2] The Art of Computer Programming, Donald E. Knuth, second
                //     edition, chapter 4.2.2.
                point2 mean = {0., 0.}, var = {0., 0.};

                // Should not happen
                if (cluster.empty()) {
                    return;
                }

                calc_cluster_properties<vecmem::device_vector, const cell>(
                    cluster, cl_id, mean, var, totalWeight);

                if (totalWeight > 0.) {
                    measurement m;
                    // normalize the cell position
                    m.local = mean;
                    // normalize the variance
                    m.variance[0] = var[0] / totalWeight;
                    m.variance[1] = var[1] / totalWeight;
                    // plus pitch^2 / 12
                    m.variance = m.variance + point2{pitch[0] * pitch[0] / 12,
                                                     pitch[1] * pitch[1] / 12};
                    // @todo add variance estimation
                    measurement_device.get_items().at(module_idx).push_back(m);
                }
            })
        .wait_and_throw();

    copy(measurement_buffer.items, measurements.get_items());

    for (std::size_t i = 0; i < cell_modules_per_event.size(); ++i) {
        auto module = cell_modules_per_event.at(i);
        measurements.get_headers().push_back(std::move(module));
    }
}

}  // namespace traccc::sycl