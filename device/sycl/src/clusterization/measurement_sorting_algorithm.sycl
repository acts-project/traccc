/** TRACCC library, part of the ACTS project (R&D line)
 *
 * (c) 2025 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

// Local include(s).
#include "../utils/calculate1DimNdRange.hpp"
#include "../utils/get_queue.hpp"
#include "../utils/oneDPL.hpp"
#include "traccc/sycl/clusterization/measurement_sorting_algorithm.hpp"

// Project include(s).
#include "traccc/clusterization/device/barcode_based_sorter.hpp"
#include "traccc/clusterization/device/sorting_index_filler.hpp"

// SYCL include(s).
#include <sycl/sycl.hpp>

namespace traccc::sycl {
namespace kernels {

/// Kernel filling the output buffer with sorted measurements.
class fill_sorted_measurements;

}  // namespace kernels

measurement_sorting_algorithm::measurement_sorting_algorithm(
    const traccc::memory_resource& mr, vecmem::copy& copy, queue_wrapper& queue,
    std::unique_ptr<const Logger> logger)
    : messaging(std::move(logger)), m_mr{mr}, m_copy{copy}, m_queue{queue} {}

measurement_sorting_algorithm::output_type
measurement_sorting_algorithm::operator()(
    const edm::measurement_collection<default_algebra>::const_view&
        measurements_view) const {

    // Exit early if there are no measurements.
    if (measurements_view.capacity() == 0) {
        return {};
    }

    // Get the SYCL queue to use for the algorithm.
    ::sycl::queue& queue = details::get_queue(m_queue.get());

    // oneDPL policy to use, forcing execution onto the same device that the
    // hand-written kernels would run on.
    auto policy = oneapi::dpl::execution::device_policy{queue};

    // Create a device container on top of the view.
    const edm::measurement_collection<default_algebra>::const_device
        measurements{measurements_view};

    // Create a vector of measurement indices, which would be sorted.
    vecmem::data::vector_buffer<unsigned int> indices(
        measurements_view.capacity(), m_mr.main);
    m_copy.get().setup(indices)->wait();
    oneapi::dpl::for_each(policy, indices.ptr(),
                          indices.ptr() + indices.capacity(),
                          device::sorting_index_filler{indices});

    // Sort the indices according to the surface identifiers of the
    // measurements.
    oneapi::dpl::sort(
        policy, indices.ptr(), indices.ptr() + indices.capacity(),
        device::barcode_based_sorter{measurements.surface_link()});

    // Create the output buffer.
    output_type result{measurements_view.capacity(), m_mr.main,
                       vecmem::data::buffer_type::resizable};
    m_copy.get().setup(result)->wait();
    m_copy.get()(measurements_view.size(), result.size())->wait();

    // Fill it with the sorted measurements.
    queue
        .submit([&](::sycl::handler& h) {
            h.parallel_for<kernels::fill_sorted_measurements>(
                details::calculate1DimNdRange(measurements_view.capacity(),
                                              256),
                [measurements_view, output_view = vecmem::get_data(result),
                 sorted_indices_view =
                     vecmem::get_data(indices)](::sycl::nd_item<1> item) {
                    // Create the device objects.
                    const edm::measurement_collection<
                        default_algebra>::const_device input{measurements_view};
                    edm::measurement_collection<default_algebra>::device output{
                        output_view};
                    const vecmem::device_vector<const unsigned int>
                        sorted_indices{sorted_indices_view};

                    // Stop early if we can.
                    const unsigned int index =
                        static_cast<unsigned int>(item.get_global_id(0));
                    if (index >= input.size()) {
                        return;
                    }

                    // Copy one measurement into the correct position.
                    output.at(index) = input.at(sorted_indices.at(index));
                });
        })
        .wait_and_throw();

    // Return the sorted buffer.
    return result;
}

}  // namespace traccc::sycl
