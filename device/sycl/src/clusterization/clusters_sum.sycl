/** TRACCC library, part of the ACTS project (R&D line)
 *
 * (c) 2022 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

// SYCL library include(s).
#include "../utils/get_queue.hpp"

// SYCL include(s).
#include <CL/sycl.hpp>

// Project include(s).
#include "clusters_sum.hpp"

namespace traccc::sycl {

void clusters_sum(
    const cell_container_types::host& cells_per_event,
    vecmem::data::jagged_vector_view<unsigned int> sparse_ccl_indices_view,
    vecmem::unique_alloc_ptr<unsigned int>& total_clusters,
    vecmem::data::vector_view<std::size_t> cluster_prefix_sum_view,
    vecmem::data::vector_view<std::size_t> clusters_per_module_view,
    vecmem::memory_resource& resource, queue_wrapper queue) {

    // Execution size of the algorithm
    std::size_t n_modules = cells_per_event.size();

    // Calculate the execution NDrange for the kernel
    auto wGroupSize = 64;
    auto num = (n_modules + wGroupSize - 1) / wGroupSize;
    auto ndrange = ::sycl::nd_range<1>{::sycl::range<1>(num * wGroupSize),
                                       ::sycl::range<1>(wGroupSize)};

    // Get the view of the cells container
    auto cells_data = get_data(cells_per_event, &resource);
    cell_container_types::const_view cells_view(cells_data);

    // Get the raw pointer of the reduction variable
    auto total_clusters_ptr = total_clusters.get();

    details::get_queue(queue)
        .submit([&ndrange, &cells_view, &sparse_ccl_indices_view,
                 &total_clusters_ptr, &cluster_prefix_sum_view,
                 &clusters_per_module_view](::sycl::handler& h) {
            h.parallel_for<class ClusterSum>(
                ndrange, [cells_view, sparse_ccl_indices_view,
                          total_clusters_ptr, cluster_prefix_sum_view,
                          clusters_per_module_view](::sycl::nd_item<1> item) {
                    // Get the global index
                    auto idx = item.get_global_linear_id();

                    // Initialize the data on the device
                    cell_container_types::const_device cells_device(cells_view);

                    // Ignore if idx is out of range
                    if (idx < cells_device.size()) {

                        // Get the cells from the current module
                        const auto& cells = cells_device.at(idx).items;

                        // Number of clusters that sparce_ccl will find for this
                        // module
                        unsigned int n_clusters = 0;

                        // Vectors used for cluster indices found by sparse CCL
                        vecmem::jagged_device_vector<unsigned int>
                            device_sparse_ccl_indices(sparse_ccl_indices_view);
                        auto cluster_indices =
                            device_sparse_ccl_indices.at(idx);

                        // Run the sparse_ccl algorithm
                        detail::sparse_ccl(cells, cluster_indices, n_clusters);

                        // Save the number of clusters found in this module at
                        // the last, extra place in the indices vectors
                        cluster_indices.back() = n_clusters;

                        auto prefix_sum =
                            vecmem::device_atomic_ref<unsigned int>(
                                *total_clusters_ptr)
                                .fetch_add(n_clusters);

                        // Save the current prefix sum at a correct index in a
                        // vector
                        vecmem::device_vector<std::size_t>
                            device_cluster_prefix_sum(cluster_prefix_sum_view);
                        device_cluster_prefix_sum[idx] = prefix_sum;

                        // At last, fill also the "number of clusters per
                        // module" for measurement creation buffer
                        vecmem::device_vector<std::size_t>
                            device_clusters_per_module(
                                clusters_per_module_view);
                        device_clusters_per_module[idx] = n_clusters;
                    }
                });
        })
        .wait_and_throw();
}

}  // namespace traccc::sycl