/** TRACCC library, part of the ACTS project (R&D line)
 *
 * (c) 2022 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

// SYCL library include(s).
#include "../utils/get_queue.hpp"

// SYCL include(s).
#include <CL/sycl.hpp>

// Project include(s).
#include "cluster_counting.hpp"

namespace traccc::sycl {

void cluster_counting(
    std::size_t num_modules,
    vecmem::data::jagged_vector_view<unsigned int> sparse_ccl_indices_view,
    vecmem::data::vector_view<unsigned int> cluster_sizes_view,
    vecmem::data::vector_view<std::size_t> cluster_prefix_sum_view,
    std::size_t cells_max, vecmem::memory_resource& resource,
    queue_wrapper queue) {

    // X dimension of the execution grid (the Y dim is the cells_max)
    auto n_modules = vecmem::make_unique_alloc<std::size_t>(resource);
    *n_modules = num_modules;

    // Calculate the 2-dim NDrange for the kernel
    // For now only size 32 and smaller is possible (for higher, there is
    // problem with non-uniform work groups in x and y dimensions)
    // For Intel the size should be changed to 16
    auto wGroupSize = 16;
    auto numGroupsX = (*n_modules + wGroupSize - 1) / wGroupSize;
    auto numGroupsY = (cells_max + wGroupSize - 1) / wGroupSize;
    auto ndrange = ::sycl::nd_range<2>{
        ::sycl::range<2>(numGroupsX * wGroupSize, numGroupsY * wGroupSize),
        ::sycl::range<2>(wGroupSize, wGroupSize)};

    // Get the raw pointer to pass to the kernel
    auto n_modules_ptr = n_modules.get();

    details::get_queue(queue)
        .submit([&ndrange, &n_modules_ptr, &sparse_ccl_indices_view,
                 &cluster_sizes_view,
                 &cluster_prefix_sum_view](::sycl::handler& h) {
            h.parallel_for<class ClusterCounting>(
                ndrange,
                [sparse_ccl_indices_view, n_modules_ptr, cluster_sizes_view,
                 cluster_prefix_sum_view](::sycl::nd_item<2> item) {
                    // Get the current module id_x and current cell in this
                    // module id_y
                    auto id_x = item.get_global_id(0);
                    auto id_y = item.get_global_id(1);

                    // Ignore if id_x is out of range
                    if (id_x >= *n_modules_ptr)
                        return;

                    // Vectors used for cluster indices found by sparse CCL
                    vecmem::jagged_device_vector<unsigned int>
                        device_sparse_ccl_indices(sparse_ccl_indices_view);
                    const auto& cluster_indices =
                        device_sparse_ccl_indices.at(id_x);

                    // Ignore if id_y is out of range (more than num of cells
                    // for this module)
                    if (id_y >= cluster_indices.size())
                        return;

                    // Number of clusters that sparce_ccl found for this module
                    const unsigned int n_clusters = cluster_indices.back();

                    // Get the prefix sum at this id_x to know where to write
                    // clusters from this module to the cluster_container
                    vecmem::device_vector<std::size_t>
                        device_cluster_prefix_sum(cluster_prefix_sum_view);
                    const std::size_t prefix_sum =
                        device_cluster_prefix_sum[id_x];

                    // Vector to fill in with the sizes of each cluster
                    vecmem::device_vector<unsigned int> device_cluster_sizes(
                        cluster_sizes_view);

                    // Count the cluster sizes for each position
                    unsigned int cindex = cluster_indices[id_y] - 1;
                    if (cindex < n_clusters) {
                        vecmem::device_atomic_ref<unsigned int>(
                            device_cluster_sizes[prefix_sum + cindex])
                            .fetch_add(1);
                    }
                });
        })
        .wait_and_throw();
}

}  // namespace traccc::sycl