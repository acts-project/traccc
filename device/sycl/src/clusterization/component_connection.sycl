/** TRACCC library, part of the ACTS project (R&D line)
 *
 * (c) 2022 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

// SYCL library include(s).
#include "../utils/get_queue.hpp"

// SYCL include(s).
#include <CL/sycl.hpp>

// Project include(s).
#include "component_connection.hpp"

namespace traccc::sycl {

void component_connection(
    cluster_container_view clusters_view,
    const cell_container_types::host& cells_per_event,
    vecmem::data::vector_view<unsigned int> clusters_count_view,
    vecmem::unique_alloc_ptr<unsigned int>& total_clusters,
    vecmem::memory_resource& resource, queue_wrapper queue) {

    // Execution size of the algorithm
    std::size_t N = cells_per_event.size();

    // Get the sizes of the cells in each module
    std::vector<std::size_t> cell_sizes(N, 0);
    for (std::size_t j = 0; j < N; ++j) {
        cell_sizes[j] = cells_per_event.get_items().at(j).size();
    }

    // Calculate the execution NDrange for the kernel
    auto workGroupSize = 64;
    auto num = (N + workGroupSize - 1) / workGroupSize;
    auto ndrange = ::sycl::nd_range<1>{::sycl::range<1>(num * workGroupSize),
                                       ::sycl::range<1>(workGroupSize)};

    // Get the view of the cells container
    auto cells_data = get_data(cells_per_event, &resource);
    cell_container_types::const_view cells_view(cells_data);

    // Helper container for sparse CCL calculations
    vecmem::data::jagged_vector_buffer<unsigned int> cluster_indices{cell_sizes,
                                                                     resource};
    vecmem::data::jagged_vector_view<unsigned int> cluster_indices_view(
        cluster_indices);

    // Get the raw pointer of the total clusters
    auto total_clusters_ptr = total_clusters.get();

    details::get_queue(queue)
        .parallel_for<class ComponentConnection>(
            ndrange,
            [cells_view, total_clusters_ptr, clusters_view,
             cluster_indices_view,
             clusters_count_view](::sycl::nd_item<1> item) {
                // Get the global index
                auto idx = item.get_global_linear_id();

                // Initialize the data on the device
                cell_container_types::const_device cells_device(cells_view);
                device_cluster_container clusters_device(clusters_view);

                // Ignore if idx is out of range
                if (idx >= cells_device.size())
                    return;

                // Get the cells from the current module
                const auto& cells = cells_device.at(idx).items;
                const auto& module = cells_device.at(idx).header;

                // Number of clusters that sparce_ccl will find for this module
                unsigned int num_clusters = 0;

                // Vectors used for cluster indices found by sparse CCL
                vecmem::jagged_device_vector<unsigned int>
                    device_cluster_indices(cluster_indices_view);
                auto cluster_indices = device_cluster_indices.at(idx);

                // Run the sparse_ccl algorithm
                detail::sparse_ccl(cells, cluster_indices, num_clusters);

                // Add the number of found clusers per module to the count
                // vector
                vecmem::device_vector<unsigned int> clusters_count_device(
                    clusters_count_view);
                clusters_count_device[idx] += num_clusters;

                // Create cluster id - same for all clusters in this module
                cluster_id cl_id{};
                cl_id.module = module.module;
                cl_id.placement = module.placement;
                cl_id.module_idx = idx;
                cl_id.pixel = module.pixel;

                // Atomically add the number of created clusters
                auto current_clusters =
                    vecmem::device_atomic_ref<unsigned int>(*total_clusters_ptr)
                        .fetch_add(num_clusters);

                // Push back the cells to the correct item vector
                unsigned int cindex;
                for (std::size_t j = 0; j < cells.size(); ++j) {
                    cindex = cluster_indices[j] - 1;
                    if (cindex < num_clusters) {
                        clusters_device[cindex + current_clusters].header =
                            cl_id;
                        clusters_device[cindex + current_clusters]
                            .items.push_back(cells[j]);
                    }
                }
            })
        .wait_and_throw();
}

}  // namespace traccc::sycl
