/** TRACCC library, part of the ACTS project (R&D line)
 *
 * (c) 2022 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

#define VECMEM_DEBUG_MSG_LVL 1

// SYCL library include(s)
#include "../utils/get_queue.hpp"

//Project include(s).
#include "traccc/sycl/clusterization/component_connection.hpp"

// SYCL include(s).
#include <CL/sycl.hpp>

// Vecmem include(s).
#include <vecmem/utils/sycl/copy.hpp>
#include <vecmem/utils/debug.hpp>

#include <iostream>

namespace traccc::sycl {

component_connection::component_connection(vecmem::memory_resource &mr,
                                           queue_wrapper queue)
        : m_mr(mr), m_queue(queue) {}

host_cluster_container component_connection::operator()( 
    const host_cell_container &c) const {
    output_type clusters(&m_mr.get());
    this->operator()(c, clusters);
    return clusters;
}

void component_connection::operator()(
    const host_cell_container &cells_per_event,
    output_type &clusters) const {

    // Calculate the execution NDrange for the kernel
    // auto workGroupSize = 32;
    // auto num = (cells_per_event.size() + workGroupSize - 1) / workGroupSize;
    // auto ndrange = ::sycl::nd_range<1>{::sycl::range<1>(num*workGroupSize), ::sycl::range<1>(workGroupSize)};

    vecmem::sycl::copy copy{m_queue.queue()};

    // Find the largest cell collection
    unsigned int max_size_cells = 0;
    for (auto& cells : cells_per_event.get_items()){
        if (cells.size() > max_size_cells) max_size_cells = cells.size();
    }
    unsigned int cells_total_size = cells_per_event.total_size();

    // Resizable buffer the clusters
    // For now assuming the worst case where 1 cell = 1 cluster
    // and max. number of cells per module is max. number of cells per cluster
    cluster_container_buffer clusters_buffer{{cells_total_size, 0, m_mr.get()},
                                             {std::vector<std::size_t>(cells_total_size, 0),
                                              std::vector<std::size_t>(cells_total_size, max_size_cells), m_mr.get()}};

    vecmem::data::jagged_vector_buffer<cell> clusters_new{std::vector<std::size_t>(cells_total_size, 0),
                                                    std::vector<std::size_t>(cells_total_size, max_size_cells), m_mr.get()};
    copy.setup(clusters_new);
    copy.setup(clusters_buffer.headers);
    copy.setup(clusters_buffer.items);
    cluster_container_view clusters_view(clusters_buffer);

    vecmem::data::jagged_vector_view<cell> clusters_new_view(clusters_new);

    // Cells per event view to pass to the device
    auto cells_data = get_data(cells_per_event, &m_mr.get());
    cell_const_container_view cells_view(cells_data);

    std::vector<std::size_t> cell_sizes(cells_per_event.size(), 0);
    for (unsigned long j = 0; j < cell_sizes.size(); ++j){
        cell_sizes[j] = cells_per_event.get_items().at(j).size();
    }
    // Helper container for sparse CCL calculations
    vecmem::data::jagged_vector_buffer<unsigned int> cluster_indices{cell_sizes, m_mr.get()};
    // Setup for Debugging
    // copy.setup(cluster_indices);
    vecmem::data::jagged_vector_view<unsigned int> cluster_indices_view(cluster_indices);

    // Calculate the 1 dimensional range
    auto range = ::sycl::range<1>(cells_per_event.size());

    // Debugging counter 
    // vecmem::vector<unsigned long> count_items(1, 0, &m_mr.get());
    // auto count_it_view = vecmem::get_data(count_items);

    details::get_queue(m_queue).submit([&cells_view, &clusters_new_view, &range, &clusters_view, &cluster_indices_view](::sycl::handler& h) {


        // ::sycl::stream out(8192, 512, h);

        h.parallel_for(range, [cells_view, clusters_new_view, 
                                clusters_view, cluster_indices_view](::sycl::id<1> idx){
            
            // auto idx = item.get_global_linear_id();
            // auto local_idx = item.get_local_linear_id();

            device_cell_const_container cells_device(cells_view);
            device_cluster_container clusters_device(clusters_view);
            vecmem::jagged_device_vector<cell> clusters_new_device(clusters_new_view);

            // Ignore if idx is out of range
            if (idx >= cells_device.size())
                return;

            // Get the cells from the current module
            const auto& cells = cells_device.get_items().at(idx);
            const auto& module = cells_device.get_headers().at(idx);
                        
            // Number of clusters per module
            unsigned int num_clusters = 0; 

            // Vectors used for cluster indices found by sparse CCL
            vecmem::jagged_device_vector<unsigned int> device_cluster_indices(cluster_indices_view);
            auto cluster_indices = device_cluster_indices.at(idx);

            // Run the sparse_ccl algorithm
            // detail::sparse_ccl_device<vecmem::device_vector, const cell>(cells, cluster_indices, num_clusters, cells.size());

            ///////////////////// SPARSE CCL //////////////////////////////////


            // first scan: pixel association
            unsigned int start_j = 0;
            for (unsigned int i = 0; i < cells.size(); ++i) {

                cluster_indices[i] = i;
                unsigned int ai = i;
                if (i > 0) {
                    for (unsigned int j = start_j; j < i; ++j) {
                        unsigned int chj0 = cells[j].channel0;
                        unsigned int chj1 = cells[j].channel1;
                        unsigned int chi1 = cells[i].channel1;
                        unsigned int chi0 = cells[i].channel0;
                        if ((chi0 - chj0) * (chi0 - chj0) <= 1 &&
                            (chi1 - chj1) * (chi1 - chj1) <= 1 ) {

                            /// Find a root
                            unsigned int r = j;
                            while (cluster_indices[r] != r ) {
                                r = cluster_indices[r];
                            }
                            
                            /// Make a Union`
                            unsigned int e;
                            if (ai < r) {
                                e = ai;
                                cluster_indices[r] = e;
                            } else {
                                e = r;
                                cluster_indices[ai] = e;
                            }
                            ai = e;
                        } else if ((cells[i].channel1 - cells[j].channel1) > 1) {
                            ++start_j;
                        }
                    }
                }
            }

            // second scan: transitive closure
            for (unsigned int i = 0; i < cells.size(); ++i) {
                unsigned int l = 0;
                if (cluster_indices[i] == i) {
                    ++num_clusters;
                    l = num_clusters;
                } else {
                    l = cluster_indices[cluster_indices[i]];
                }
                cluster_indices[i] = l;
            }
            ////////////////////////////// SPARSE CCL END /////////////////////////////////////

            // Create cluster id - same for all clusters in this module
            cluster_id cl_id{};
            cl_id.module = module.module;
            cl_id.placement = module.placement;
            cl_id.module_idx = idx;
            cl_id.pixel = module.pixel;

            // Push back the cluster id(s) to the header vector
            for (uint32_t i = 0; i < num_clusters; ++i) {
                clusters_device.get_headers().push_back(cl_id);
            }

            // Push back the cells to the correct item vector
            unsigned int cindex = 0;
            unsigned int icell = 0;
            for(std::size_t j = 0; j < cells.size(); ++j){
                cindex = cluster_indices[j] - 1;
                if (cindex < num_clusters) {
                    // cell c{};
                    // c.channel0 = cells[icell].channel0;
                    // c.channel1 = cells[icell].channel1;
                    // c.activation = cells[icell].activation;
                    // c.time = cells[icell].time;
                    // ++icell;
                    // clusters_device.get_items()[cindex].push_back(cells[icell++]);
                    clusters_new_device[cindex].push_back(cells[icell++]);

                    // Debugging atomic counter
                    // vecmem::device_vector<unsigned long> count_device(count_it_view);
                    // vecmem::device_atomic_ref<unsigned long> obj(count_device[0]);
                    // obj.fetch_add(1);
                }
            }
        });
    }).wait_and_throw();

    // Get the sizes of buffer items for debugging purposes
    // int non_empty_sizes = 0;
    // auto sizes = copy.get_sizes(clusters_buffer.items);
    // for (auto s : sizes) if (s != 0 ) non_empty_sizes++;
    // std::cout << "non empty buffer clusters: " << non_empty_sizes << "\n"; 

    // Copy the data to host vector containers
    copy(clusters_buffer.headers, clusters.get_headers());
    copy(clusters_new, clusters.get_items());

    // Count and print how many non_empty clusters were found - should be 36907 
    int non_empty = 0;
    for (auto& items : clusters.get_items() ){
        if (!items.empty()) non_empty++;
    }
    std::cout << "non empty host clusters: " << non_empty << "\n";

    // Print the size of cluster headers that were added - this works correctly - prints 36907 
    std::cout << "cluster headers: " << clusters.get_headers().size() << "\n";


    //////////////////// Some more Debugging ///////////////////////////////////////////


    // Print the vectors found through Sparse CCL
    // vecmem::jagged_vector<unsigned int> cluster_indices_copy(&m_mr.get());
    // copy(cluster_indices, cluster_indices_copy);
    // for(auto item : cluster_indices_copy){
    //     for (auto i : item) std::cout << i << " ";
    //     std::cout << "\n";
    // }
    // std::cout << "indices: " << cluster_indices_copy.size() << " ";

    // Debugging count 
    // std::cout << "atomic count: " << count_items[0] << " ";

}

} // namespace traccc::sycl


