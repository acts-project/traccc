/** TRACCC library, part of the ACTS project (R&D line)
 *
 * (c) 2022 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

// SYCL library include(s)
#include "../utils/get_queue.hpp"

// SYCL include(s).
#include <CL/sycl.hpp>

// Project include(s).
#include "traccc/sycl/clusterization/component_connection.hpp"

// Vecmem include(s).
#include <vecmem/utils/sycl/copy.hpp>

namespace traccc::sycl {

component_connection::component_connection(vecmem::memory_resource& mr,
                                           queue_wrapper queue)
    : m_mr(mr), m_queue(queue) {}

host_cluster_container component_connection::operator()(
    const host_cell_container& cells_per_event) const {

    // Create the output container
    output_type clusters(&m_mr.get());

    // Execution size of the algorithm
    unsigned int N = cells_per_event.size();

    // Vecmem copy object for moving data between host and device
    vecmem::sycl::copy copy{m_queue.queue()};

    // Find the largest cell collection
    // to estimate max. size of cluster (assuming that this cell collection
    // would constitute to the whole cluster)
    unsigned int max_cluster_size =
        std::max_element(
            cells_per_event.get_items().begin(),
            cells_per_event.get_items().end(),
            [](auto& c1, auto& c2) { return c1.size() < c2.size(); })
            ->size();

    // Number of cells from all the modules
    unsigned int cells_total_size = cells_per_event.total_size();

    // Cluster container buffer for the clusters and headers (cluster ids)
    // assuming the worst case where 1 cell = 1 cluster
    // and max. number of cells per module is max. number of cells per cluster
    cluster_container_buffer clusters_buffer{
        {cells_total_size, m_mr.get()},
        {std::vector<std::size_t>(cells_total_size, 0),
         std::vector<std::size_t>(cells_total_size, max_cluster_size),
         m_mr.get()}};
    copy.setup(clusters_buffer.headers);
    copy.setup(clusters_buffer.items);
    cluster_container_view clusters_view(clusters_buffer);

    // Cells view to pass to the device
    auto cells_data = get_data(cells_per_event, &m_mr.get());
    cell_container_const_view cells_view(cells_data);

    // Get the sizes of the cells in each module
    std::vector<std::size_t> cell_sizes(N, 0);
    for (unsigned long j = 0; j < cell_sizes.size(); ++j) {
        cell_sizes[j] = cells_per_event.get_items().at(j).size();
    }

    // Helper container for sparse CCL calculations
    vecmem::data::jagged_vector_buffer<unsigned int> cluster_indices{
        cell_sizes, m_mr.get()};
    vecmem::data::jagged_vector_view<unsigned int> cluster_indices_view(
        cluster_indices);

    // Single-item vector for the atomic count of number of clusters
    vecmem::vector<unsigned int> total_clusters(1, 0, &m_mr.get());
    auto total_clusters_view = vecmem::get_data(total_clusters);

    details::get_queue(m_queue)
        .parallel_for(
            N,
            [cells_view, total_clusters_view, clusters_view,
             cluster_indices_view](auto idx) {
                // Initialize the data on the device
                device_cell_const_container cells_device(cells_view);
                device_cluster_container clusters_device(clusters_view);

                // Ignore if idx is out of range
                if (idx >= cells_device.size())
                    return;

                // Get the cells from the current module
                const auto& cells = cells_device.at(idx).items;
                const auto& module = cells_device.at(idx).header;

                // Number of clusters that sparce_ccl will find for this module
                unsigned int num_clusters = 0;

                // Vectors used for cluster indices found by sparse CCL
                vecmem::jagged_device_vector<unsigned int>
                    device_cluster_indices(cluster_indices_view);
                auto cluster_indices = device_cluster_indices.at(idx);

                // Run the sparse_ccl algorithm
                detail::sparse_ccl<vecmem::device_vector, const traccc::cell>(
                    cells, cluster_indices, num_clusters);

                // Create cluster id - same for all clusters in this module
                cluster_id cl_id{};
                cl_id.module = module.module;
                cl_id.placement = module.placement;
                cl_id.module_idx = idx;
                cl_id.pixel = module.pixel;

                // Atomically add the number of created clusters
                vecmem::device_vector<unsigned int> total_clusters_device(
                    total_clusters_view);
                auto total_clusters = vecmem::device_atomic_ref<unsigned int>(
                                          total_clusters_device[0])
                                          .fetch_add(num_clusters);

                // Push back the cells to the correct item vector
                unsigned int cindex;
                for (std::size_t j = 0; j < cells.size(); ++j) {
                    cindex = cluster_indices[j] - 1;
                    if (cindex < num_clusters) {
                        clusters_device[cindex + total_clusters].header = cl_id;
                        clusters_device[cindex + total_clusters]
                            .items.push_back(cells[j]);
                    }
                }
            })
        .wait_and_throw();

    // Copy the data to host vector containers
    copy(clusters_buffer.headers, clusters.get_headers());
    copy(clusters_buffer.items, clusters.get_items());

    return clusters;
}

}  // namespace traccc::sycl
