/** TRACCC library, part of the ACTS project (R&D line)
 *
 * (c) 2022-2024 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

// Local include(s).
#include "../sanity/contiguous_on.hpp"
#include "../sanity/ordered_on.hpp"
#include "../utils/barrier.hpp"
#include "../utils/calculate1DimNdRange.hpp"
#include "../utils/get_queue.hpp"
#include "../utils/thread_id.hpp"
#include "traccc/sycl/clusterization/clusterization_algorithm.hpp"

// Project include(s)
#include "traccc/clusterization/device/ccl_kernel.hpp"
#include "traccc/clusterization/device/reify_cluster_data.hpp"
#include "traccc/utils/projections.hpp"
#include "traccc/utils/relations.hpp"

// Vecmem include(s).
#include <vecmem/utils/sycl/local_accessor.hpp>

namespace traccc::sycl {
namespace kernels {

/// Class identifying the kernel running @c traccc::device::ccl_kernel
class ccl_kernel;
/// Class identifying the kernel running @c traccc::device::reify_cluster_data
class reify_cluster_data;

}  // namespace kernels

clusterization_algorithm::clusterization_algorithm(
    const traccc::memory_resource& mr, vecmem::copy& copy, queue_wrapper& queue,
    const config_type& config, std::unique_ptr<const Logger> logger)
    : device::clusterization_algorithm(mr, copy, config, std::move(logger)),
      m_queue(queue) {}

bool clusterization_algorithm::input_is_valid(
    const edm::silicon_cell_collection::const_view& cells) const {

    return (is_contiguous_on<edm::silicon_cell_collection::const_device>(
                cell_module_projection(), mr().main, copy(),
                details::get_queue(m_queue), cells) &&
            is_ordered_on<edm::silicon_cell_collection::const_device>(
                channel0_major_cell_order_relation(), mr().main, copy(),
                details::get_queue(m_queue), cells));
}

void clusterization_algorithm::ccl_kernel(
    unsigned int num_cells, const config_type& config,
    const edm::silicon_cell_collection::const_view& cells,
    const silicon_detector_description::const_view& det_descr,
    edm::measurement_collection<default_algebra>::view& measurements,
    vecmem::data::vector_view<unsigned int>& cell_links,
    vecmem::data::vector_view<device::details::index_t>& f_backup,
    vecmem::data::vector_view<device::details::index_t>& gf_backup,
    vecmem::data::vector_view<unsigned char>& adjc_backup,
    vecmem::data::vector_view<device::details::index_t>& adjv_backup,
    unsigned int* backup_mutex,
    vecmem::data::vector_view<unsigned int>& disjoint_set,
    vecmem::data::vector_view<unsigned int>& cluster_sizes) const {

    // Check if device is capable of allocating sufficient local memory
    assert(sizeof(device::details::index_t) * 2 * config.max_partition_size() +
               3 * sizeof(std::size_t) <
           details::get_queue(m_queue)
               .get_device()
               .get_info<::sycl::info::device::local_mem_size>());

    std::size_t num_blocks = (num_cells + config.target_partition_size() - 1) /
                             config.target_partition_size();
    const ::sycl::nd_range cclKernelRange(
        ::sycl::range<1>(num_blocks * config.threads_per_partition),
        ::sycl::range<1>(config.threads_per_partition));
    details::get_queue(m_queue)
        .submit([&](::sycl::handler& h) {
            // Allocate shared memory for the kernel.
            vecmem::sycl::local_accessor<std::size_t> shared_uint(3, h);
            vecmem::sycl::local_accessor<device::details::index_t> shared_idx(
                2 * config.max_partition_size(), h);

            // Launch the kernel.
            h.parallel_for<kernels::ccl_kernel>(
                cclKernelRange,
                [shared_uint, shared_idx, cells, det_descr, measurements,
                 cell_links, f_backup, gf_backup, adjc_backup, adjv_backup,
                 backup_mutex, config, disjoint_set,
                 cluster_sizes](::sycl::nd_item<1> item) {
                    // Construct more readable variable names.
                    using vector_size_t = vecmem::data::vector_view<
                        device::details::index_t>::size_type;
                    vecmem::data::vector_view<device::details::index_t> f_view{
                        static_cast<vector_size_t>(config.max_partition_size()),
                        &shared_idx[0]};
                    vecmem::data::vector_view<device::details::index_t> gf_view{
                        static_cast<vector_size_t>(config.max_partition_size()),
                        &shared_idx[config.max_partition_size()]};
                    std::size_t& partition_start = shared_uint[0];
                    std::size_t& partition_end = shared_uint[1];
                    std::size_t& outi = shared_uint[2];

                    // Mutex for scratch space
                    vecmem::device_atomic_ref<unsigned int> mutex(
                        *backup_mutex);

                    // Barrier used in the algorithm.
                    const details::barrier barrier{item};
                    const details::thread_id thread_id{item};

                    // Run the algorithm for this thread.
                    device::ccl_kernel(config, thread_id, cells, det_descr,
                                       partition_start, partition_end, outi,
                                       f_view, gf_view, f_backup, gf_backup,
                                       adjc_backup, adjv_backup, mutex,
                                       disjoint_set, cluster_sizes, barrier,
                                       measurements, cell_links);
                });
        })
        .wait_and_throw();
}

void clusterization_algorithm::cluster_maker_kernel(
    unsigned int num_cells,
    const vecmem::data::vector_view<unsigned int>& disjoint_set,
    edm::silicon_cluster_collection::view& cluster_data) const {

    const ::sycl::nd_range range =
        details::calculate1DimNdRange(num_cells, 256);
    details::get_queue(m_queue)
        .submit([&](::sycl::handler& h) {
            h.parallel_for<kernels::reify_cluster_data>(
                range, [disjoint_set, cluster_data](::sycl::nd_item<1> item) {
                    device::reify_cluster_data(
                        static_cast<unsigned int>(item.get_global_linear_id()),
                        disjoint_set, cluster_data);
                });
        })
        .wait_and_throw();
}

}  // namespace traccc::sycl
