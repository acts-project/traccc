/** TRACCC library, part of the ACTS project (R&D line)
 *
 * (c) 2021 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

#define EIGEN_DONT_VECTORIZE

#include "sycl/seeding/seed_selecting.hpp"
#include "vecmem/memory/atomic.hpp"
#include "sycl/seeding/detail/sycl_helper.hpp"

namespace traccc {
namespace sycl {

class SeedSelect {
public:
    SeedSelect(const seedfilter_config& filter_config,
               internal_spacepoint_container_view internal_sp_view,
               doublet_counter_container_view doublet_counter_view,
               triplet_counter_container_view triplet_counter_view,
               triplet_container_view triplet_view, 
               seed_container_view seed_view,
               local_accessor<triplet> localMem,
               local_accessor<std::byte> scratch,
               std::size_t temp_memory_size)
    : m_filter_config(filter_config),
      m_internal_sp_view(internal_sp_view),
      m_doublet_counter_view(doublet_counter_view),
      m_triplet_counter_view(triplet_counter_view),
      m_triplet_view(triplet_view),
      m_seed_view(seed_view),
      m_localMem(localMem),
      m_scratch(scratch),
      m_temp_memory_size(m_temp_memory_size) {}

      void operator()(::sycl::nd_item<3> item) const {

         // Mapping cuda indexing to dpc++
        auto workGroup = item.get_group();
        
        // Equivalent to blockIdx.x in cuda
        auto groupIdx = item.get_group(2);
        // Equivalent to blockDim.x in cuda
        auto groupDim = item.get_local_range(2);
        // Equivalent to threadIdx.x in cuda
        auto workItemIdx = item.get_local_id(2);

        device_internal_spacepoint_container internal_sp_device(
        {m_internal_sp_view.headers, m_internal_sp_view.items});
        device_doublet_counter_container doublet_counter_device(
            {m_doublet_counter_view.headers, m_doublet_counter_view.items});
        device_triplet_counter_container triplet_counter_device(
            {m_triplet_counter_view.headers, m_triplet_counter_view.items});
        device_triplet_container triplet_device(
            {m_triplet_view.headers, m_triplet_view.items});
        device_seed_container seed_device({m_seed_view.headers, m_seed_view.items});

        // Get the bin index of spacepoint binning and reference block idx for the
        // bin index
        unsigned int bin_idx = 0;
        unsigned int ref_block_idx = 0;
        sycl_helper::get_header_idx(triplet_counter_device, bin_idx, ref_block_idx, item);

        // Header of internal spacepoint container : spacepoint bin information
        // Item of internal spacepoint container : internal spacepoint objects per
        // bin
        auto internal_sp_per_bin = internal_sp_device.get_items().at(bin_idx);
        auto& num_compat_spM_per_bin =
            doublet_counter_device.get_headers().at(bin_idx);

        // Header of doublet counter : number of compatible middle sp per bin
        // Item of doublet counter : doublet counter objects per bin
        auto doublet_counter_per_bin =
            doublet_counter_device.get_items().at(bin_idx);

        // Header of triplet counter: number of compatible mid_top doublets per bin
        // Item of triplet counter: triplet counter objects per bin
        auto& num_compat_mb_per_bin =
            triplet_counter_device.get_headers().at(bin_idx);

        // Header of triplet: number of triplets per bin
        // Item of triplet: triplet objects per bin
        auto& num_triplets_per_bin = triplet_device.get_headers().at(bin_idx);
        auto triplets_per_bin = triplet_device.get_items().at(bin_idx);

        // Header of seed: number of seeds per event
        // Item of seed: seed objects per event
        auto& num_seeds = seed_device.get_headers().at(0);
        auto seeds = seed_device.get_items().at(0);

        auto triplets_per_spM = m_localMem.get_pointer();

        // index of doublet counter in the item vector
        auto gid = (groupIdx - ref_block_idx) * groupDim + workItemIdx;

        // prevent overflow
        if (gid < num_compat_spM_per_bin) {
            
            // middle spacepoint index
            auto& spM_loc = doublet_counter_per_bin[gid].spM;
            auto& spM_idx = spM_loc.sp_idx;
            // middle spacepoint
            auto& spM = internal_sp_per_bin[spM_idx];

            // number of triplets per compatible middle spacepoint
            unsigned int n_triplets_per_spM = 0;

            // the start index of triplets_per_spM
            unsigned int stride = workItemIdx * m_filter_config.max_triplets_per_spM;

            // iterate over the triplets in the bin
            for (unsigned int i = 0; i < num_triplets_per_bin; ++i) {
                auto& aTriplet = triplets_per_bin[i];
                auto& spB_loc = aTriplet.sp1;
                auto& spT_loc = aTriplet.sp3;
                auto& spB =
                    internal_sp_device.get_items()[spB_loc.bin_idx][spB_loc.sp_idx];
                auto& spT =
                    internal_sp_device.get_items()[spT_loc.bin_idx][spT_loc.sp_idx];

                // consider only the triplets with the same middle spacepoint
                if (spM_loc == aTriplet.sp2) {

                    // update weight of triplet
                    seed_selecting_helper::seed_weight(m_filter_config, spM, spB, spT,
                                                    aTriplet.weight);

                    // check if it is a good triplet
                    if (!seed_selecting_helper::single_seed_cut(m_filter_config, spM, spB,
                                                                spT, aTriplet.weight)) {
                        continue;
                    }

                    // if the number of good triplets is larger than the threshold, the
                    // triplet with the lowest weight is removed
                    if (n_triplets_per_spM >= m_filter_config.max_triplets_per_spM) {
                        int begin_idx = stride;
                        int end_idx = stride + m_filter_config.max_triplets_per_spM;

                        // Note: min_index method gives a result different
                        //       from sorting method when there are the cases where
                        //       weight & z_vertex are same.
                        //
                        //       So min_index method reduces seed matching ratio
                        //       since the cpu version is using sorting method.
                        //
                        //       But that doesn't mean min_index method
                        //       is wrong of course
                        //
                        //       Let's not be so obsessed about achieving
                        //       perfectly same result :))))))))

                        int min_index = std::min_element(triplets_per_spM + begin_idx,
                                                        triplets_per_spM + end_idx,
                                                        [&](const triplet& lhs, const triplet& rhs){
                                                            if (lhs.weight != rhs.weight) {
                                                                return lhs.weight < rhs.weight;
                                                            } else {
                                                                return fabs(lhs.z_vertex) > fabs(rhs.z_vertex);
                                                            }
                                                        }) -
                                        triplets_per_spM;

                        auto& min_weight = triplets_per_spM[min_index].weight;

                        if (aTriplet.weight > min_weight) {
                            triplets_per_spM[min_index] = aTriplet;
                        }
                    }

                    else if (n_triplets_per_spM < m_filter_config.max_triplets_per_spM) {
                        triplets_per_spM[stride + n_triplets_per_spM] = aTriplet;
                        n_triplets_per_spM++;
                    }
                }       
            }
            // sort the triplets per spM
            ::sycl::ext::oneapi::joint_sort(
                ::sycl::ext::oneapi::experimental::
                group_with_scratchpad(
                    workGroup,
                    ::sycl::span{&m_scratch[0], m_temp_memory_size}
                ),
                static_cast<triplet*>(triplets_per_spM) + stride,
                static_cast<triplet*>(triplets_per_spM) + stride + n_triplets_per_spM,
                [](const triplet& lhs, const triplet& rhs) {
                    if (lhs.weight != rhs.weight) {
                        return lhs.weight > rhs.weight;
                    } else {
                        return fabs(lhs.z_vertex) < fabs(rhs.z_vertex);
                    }
                }
            );

            // the number of good seed per compatible middle spacepoint
            unsigned int n_seeds_per_spM = 0;

            // iterate over the good triplets for final selection of seeds
            for (unsigned int i = stride; i < stride + n_triplets_per_spM; ++i) {
                auto& aTriplet = triplets_per_spM[i];
                auto& spB_loc = aTriplet.sp1;
                auto& spT_loc = aTriplet.sp3;
                auto& spB =
                    internal_sp_device.get_items()[spB_loc.bin_idx][spB_loc.sp_idx];
                auto& spT =
                    internal_sp_device.get_items()[spT_loc.bin_idx][spT_loc.sp_idx];

                // if the number of seeds reaches the threshold, break
                if (n_seeds_per_spM >= m_filter_config.maxSeedsPerSpM + 1) {
                    break;
                }

                // check if it is a good triplet
                if (seed_selecting_helper::cut_per_middle_sp(
                        m_filter_config, spM.sp(), spB.sp(), spT.sp(), aTriplet.weight) ||
                    n_seeds_per_spM == 0) {
                    // ::sycl::ext::oneapi::atomic_ref<unsigned int, ::sycl::memory_order::seq_cst,
                    //                ::sycl::memory_scope::device,
                    //                ::sycl::access::address_space::global_space> obj (num_seeds);
                    vecmem::atomic obj(&num_seeds);

                    auto pos = obj.fetch_add(1);

                    // prevent overflow
                    if (pos >= seeds.size()) {
                        break;
                    }
                    n_seeds_per_spM++;

                    seeds[pos] = seed({spB.m_sp, spM.m_sp, spT.m_sp, aTriplet.weight,
                                    aTriplet.z_vertex});
                }
            }
        }

      }
private:
    const seedfilter_config m_filter_config;
    internal_spacepoint_container_view m_internal_sp_view;
    doublet_counter_container_view m_doublet_counter_view;
    triplet_counter_container_view m_triplet_counter_view;
    triplet_container_view m_triplet_view;
    seed_container_view m_seed_view;
    local_accessor<triplet> m_localMem;
    local_accessor<std::byte> m_scratch;
    std::size_t m_temp_memory_size;
};                                  

void seed_selecting(const seedfilter_config& filter_config,
                    host_internal_spacepoint_container& internal_sp_container,
                    host_doublet_counter_container& doublet_counter_container,
                    host_triplet_counter_container& triplet_counter_container,
                    host_triplet_container& triplet_container,
                    host_seed_container& seed_container,
                    vecmem::memory_resource* resource,
                    ::sycl::queue* q) {
    
    auto internal_sp_view = get_data(internal_sp_container, resource);
    auto doublet_counter_container_view =
        get_data(doublet_counter_container, resource);
    auto triplet_counter_container_view =
        get_data(triplet_counter_container, resource);
    auto triplet_container_view = get_data(triplet_container, resource);
    auto seed_container_view = get_data(seed_container, resource);

    // The thread-block is desinged to make each thread find triplets per
    // compatible middle-bot doublet

    // -- localSize
    // The dimension of workGroup (block) is the integer multiple of WARP_SIZE (=32)
    unsigned int localSize = 8;
    // Calculate the global number of threads to run in kernel
    unsigned int num_groups = 0;
    for (unsigned int i = 0; i < internal_sp_view.headers.size(); ++i) {
        num_groups +=
            triplet_counter_container.get_headers()[i] / localSize + 1;
    }
    unsigned int globalSize = localSize * num_groups;

    // 1 dim ND Range for the kernel
    auto seedSelectNdRange = ::sycl::nd_range<3>{::sycl::range<3>{1,1,globalSize},::sycl::range<3>{1,1,localSize}};
    
    // Shared memory for scratchspace (for sorting)
    std::size_t temp_memory_size =
        ::sycl::ext::oneapi::experimental::default_sorter<>
        ::memory_required<triplet>
        (::sycl::memory_scope::work_group, localSize*filter_config.max_triplets_per_spM);
    
    q->submit([&](::sycl::handler& h){

        // local memory initialization (equivalent to shared memory in CUDA)
        auto localMem = 
            local_accessor<triplet>(localSize * filter_config.max_triplets_per_spM, 
                                    h); 
        // scratch space for sorting
        auto scratch = 
            local_accessor<std::byte>({temp_memory_size}, h);

        SeedSelect kernel(filter_config, internal_sp_view, doublet_counter_container_view,
                          triplet_counter_container_view, triplet_container_view,
                          seed_container_view, localMem, scratch, temp_memory_size);

        h.parallel_for<class seed_select_kernel>(seedSelectNdRange, kernel);
    }).wait_and_throw();
}
} // namespace sycl
} // namesapce traccc
