/** TRACCC library, part of the ACTS project (R&D line)
 *
 * (c) 2021-2022 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

#include "sycl/seeding/seed_selecting.hpp"

namespace traccc {
namespace sycl {

// Sorting algorithm for sorting seeds in the local memory
template <typename Comparator>
static void insertionSort(
    ::sycl::multi_ptr<triplet, ::sycl::access::address_space::local_space> arr,
    int n, Comparator comp) {
    int j = 0;
    triplet key = arr[0];
    for (int i = 1; i < n; ++i) {
        key = arr[i];
        j = i - 1;
        while (j >= 0 && !comp(arr[j], key)) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}

// Kernel class for seed selecting
class SeedSelect {
    public:
    SeedSelect(const seedfilter_config filter_config,
               spacepoint_container_view spacepoints_view,
               sp_grid_view internal_sp_view,
               doublet_counter_container_view doublet_counter_view,
               triplet_counter_container_view triplet_counter_view,
               triplet_container_view triplet_view,
               seed_container_view seed_view, local_accessor<triplet> localMem)
        : m_filter_config(filter_config),
          m_spacepoints_view(spacepoints_view),
          m_internal_sp_view(internal_sp_view),
          m_doublet_counter_view(doublet_counter_view),
          m_triplet_counter_view(triplet_counter_view),
          m_triplet_view(triplet_view),
          m_seed_view(seed_view),
          m_localMem(localMem) {}

    void operator()(::sycl::nd_item<1> item) const {

        // Mapping cuda indexing to dpc++
        auto workGroup = item.get_group();

        // Equivalent to blockIdx.x in cuda
        auto groupIdx = item.get_group(0);
        // Equivalent to blockDim.x in cuda
        auto groupDim = item.get_local_range(0);
        // Equivalent to threadIdx.x in cuda
        auto workItemIdx = item.get_local_id(0);

        // Get device container for input parameters
        device_spacepoint_container spacepoints_device(
            {m_spacepoints_view.headers, m_spacepoints_view.items});

        sp_grid_device internal_sp_device(m_internal_sp_view);

        device_doublet_counter_container doublet_counter_device(
            {m_doublet_counter_view.headers, m_doublet_counter_view.items});
        device_triplet_counter_container triplet_counter_device(
            {m_triplet_counter_view.headers, m_triplet_counter_view.items});
        device_triplet_container triplet_device(
            {m_triplet_view.headers, m_triplet_view.items});
        device_seed_container seed_device(
            {m_seed_view.headers, m_seed_view.items});

        // Get the bin and item index
        unsigned int bin_idx(0), item_idx(0);
        sycl_helper::find_idx_on_container(doublet_counter_device, bin_idx,
                                           item_idx, item);
        // Header of internal spacepoint container : spacepoint bin information
        // Item of internal spacepoint container : internal spacepoint objects
        // per bin
        auto internal_sp_per_bin = internal_sp_device.bin(bin_idx);
        auto& num_compat_spM_per_bin =
            doublet_counter_device.get_headers().at(bin_idx).n_spM;

        // Header of doublet counter : number of compatible middle sp per bin
        // Item of doublet counter : doublet counter objects per bin
        auto doublet_counter_per_bin =
            doublet_counter_device.get_items().at(bin_idx);

        // Header of triplet counter: number of compatible mid_top doublets per
        // bin Item of triplet counter: triplet counter objects per bin
        auto& num_compat_mb_per_bin =
            triplet_counter_device.get_headers().at(bin_idx).n_mid_bot;

        // Header of triplet: number of triplets per bin
        // Item of triplet: triplet objects per bin
        auto& num_triplets_per_bin =
            triplet_device.get_headers().at(bin_idx).n_triplets;
        auto triplets_per_bin = triplet_device.get_items().at(bin_idx);

        // Header of seed: number of seeds per event
        // Item of seed: seed objects per event
        auto& num_seeds = seed_device.get_headers().at(0);
        auto seeds = seed_device.get_items().at(0);

        auto triplets_per_spM = m_localMem.get_pointer();

        if (item_idx >= num_compat_spM_per_bin)
            return;

        // middle spacepoint index
        auto& spM_loc = doublet_counter_per_bin[item_idx].spM;
        auto& spM_idx = spM_loc.sp_idx;
        // middle spacepoint
        auto& spM = internal_sp_per_bin[spM_idx];

        // number of triplets per compatible middle spacepoint
        unsigned int n_triplets_per_spM = 0;

        // the start index of triplets_per_spM
        unsigned int stride =
            workItemIdx * m_filter_config.max_triplets_per_spM;

        // iterate over the triplets in the bin
        for (unsigned int i = 0; i < num_triplets_per_bin; ++i) {
            auto& aTriplet = triplets_per_bin[i];
            auto& spB_loc = aTriplet.sp1;
            auto& spT_loc = aTriplet.sp3;
            auto& spB = internal_sp_device.bin(spB_loc.bin_idx)[spB_loc.sp_idx];
            auto& spT = internal_sp_device.bin(spT_loc.bin_idx)[spT_loc.sp_idx];

            // consider only the triplets with the same middle spacepoint
            if (spM_loc == aTriplet.sp2) {

                // update weight of triplet
                seed_selecting_helper::seed_weight(m_filter_config, spM, spB,
                                                   spT, aTriplet.weight);

                // check if it is a good triplet
                if (!seed_selecting_helper::single_seed_cut(
                        m_filter_config, spM, spB, spT, aTriplet.weight)) {
                    continue;
                }

                // if the number of good triplets is larger than the threshold,
                // the triplet with the lowest weight is removed
                if (n_triplets_per_spM >=
                    m_filter_config.max_triplets_per_spM) {
                    int begin_idx = stride;
                    int end_idx = stride + m_filter_config.max_triplets_per_spM;

                    int min_index =
                        std::min_element(triplets_per_spM + begin_idx,
                                         triplets_per_spM + end_idx,
                                         [&](triplet& lhs, triplet& rhs) {
                                             return lhs.weight < rhs.weight;
                                         }) -
                        triplets_per_spM;

                    auto& min_weight = triplets_per_spM[min_index].weight;

                    if (aTriplet.weight > min_weight) {
                        triplets_per_spM[min_index] = aTriplet;
                    }
                }

                else if (n_triplets_per_spM <
                         m_filter_config.max_triplets_per_spM) {
                    triplets_per_spM[stride + n_triplets_per_spM] = aTriplet;
                    n_triplets_per_spM++;
                }
            }
        }
        // sort the triplets per spM
        insertionSort(
            triplets_per_spM + stride, n_triplets_per_spM,
            [&](triplet& lhs, triplet& rhs) {
                if (lhs.weight != rhs.weight) {
                    return lhs.weight > rhs.weight;
                } else {

                    scalar seed1_sum = 0;
                    scalar seed2_sum = 0;

                    auto& ispB1 =
                        internal_sp_device.bin(lhs.sp1.bin_idx)[lhs.sp1.sp_idx];
                    auto& ispT1 =
                        internal_sp_device.bin(lhs.sp3.bin_idx)[lhs.sp3.sp_idx];
                    auto& ispB2 =
                        internal_sp_device.bin(rhs.sp1.bin_idx)[rhs.sp1.sp_idx];
                    auto& ispT2 =
                        internal_sp_device.bin(rhs.sp3.bin_idx)[rhs.sp3.sp_idx];

                    const auto& spB1 = spacepoints_device.at(ispB1.m_link);
                    const auto& spT1 = spacepoints_device.at(ispT1.m_link);
                    const auto& spB2 = spacepoints_device.at(ispB2.m_link);
                    const auto& spT2 = spacepoints_device.at(ispT2.m_link);

                    seed1_sum += pow(spB1.y(), 2) + pow(spB1.z(), 2);
                    seed1_sum += pow(spT1.y(), 2) + pow(spT1.z(), 2);
                    seed2_sum += pow(spB2.y(), 2) + pow(spB2.z(), 2);
                    seed2_sum += pow(spT2.y(), 2) + pow(spT2.z(), 2);

                    return seed1_sum > seed2_sum;
                }
            });
        // the number of good seed per compatible middle spacepoint
        unsigned int n_seeds_per_spM = 0;

        // iterate over the good triplets for final selection of seeds
        for (unsigned int i = stride; i < stride + n_triplets_per_spM; ++i) {
            auto& aTriplet = triplets_per_spM[i];
            auto& spB_loc = aTriplet.sp1;
            auto& spT_loc = aTriplet.sp3;
            auto& spB = internal_sp_device.bin(spB_loc.bin_idx)[spB_loc.sp_idx];
            auto& spT = internal_sp_device.bin(spT_loc.bin_idx)[spT_loc.sp_idx];

            // if the number of seeds reaches the threshold, break
            if (n_seeds_per_spM >= m_filter_config.maxSeedsPerSpM + 1) {
                break;
            }

            seed aSeed({spB.m_link, spM.m_link, spT.m_link, aTriplet.weight,
                        aTriplet.z_vertex});

            // check if it is a good triplet
            if (seed_selecting_helper::cut_per_middle_sp(
                    m_filter_config, spacepoints_device, aSeed,
                    aTriplet.weight) ||
                n_seeds_per_spM == 0) {

                vecmem::atomic<uint32_t> obj(&num_seeds);
                auto pos = obj.fetch_add(1);

                // prevent overflow
                if (pos >= seeds.size()) {
                    break;
                }
                n_seeds_per_spM++;

                seeds[pos] = aSeed;
            }
        }
    }

    private:
    const seedfilter_config m_filter_config;
    spacepoint_container_view m_spacepoints_view;
    sp_grid_view m_internal_sp_view;
    doublet_counter_container_view m_doublet_counter_view;
    triplet_counter_container_view m_triplet_counter_view;
    triplet_container_view m_triplet_view;
    seed_container_view m_seed_view;
    local_accessor<triplet> m_localMem;
};

void seed_selecting(const seedfilter_config& filter_config,
                    host_spacepoint_container& spacepoints,
                    sp_grid& internal_sp,
                    host_doublet_counter_container& doublet_counter_container,
                    host_triplet_counter_container& triplet_counter_container,
                    host_triplet_container& triplet_container,
                    host_seed_container& seed_container,
                    vecmem::memory_resource& resource, ::sycl::queue* q) {

    auto spacepoints_view = get_data(spacepoints, &resource);
    auto doublet_counter_container_view =
        get_data(doublet_counter_container, &resource);
    auto triplet_counter_container_view =
        get_data(triplet_counter_container, &resource);
    auto triplet_container_view = get_data(triplet_container, &resource);
    auto seed_container_view = get_data(seed_container, &resource);
    auto internal_sp_view = get_data(internal_sp, resource);

    // The thread-block is desinged to make each thread find triplets per
    // compatible middle-bot doublet

    // -- localSize
    // The dimension of workGroup (block) is the integer multiple of WARP_SIZE
    // (=32)
    unsigned int localSize = 64;
    // Calculate the global number of threads to run in kernel
    unsigned int num_groups = 0;
    for (unsigned int i = 0; i < internal_sp.nbins(); ++i) {
        num_groups +=
            doublet_counter_container.get_headers()[i].n_spM / localSize + 1;
    }
    unsigned int globalSize = localSize * num_groups;

    // 1 dim ND Range for the kernel
    auto seedSelectNdRange = ::sycl::nd_range<1>{globalSize, localSize};

    q->submit([&](::sycl::handler& h) {
         // local memory initialization (equivalent to shared memory in CUDA)
         auto localMem = local_accessor<triplet>(
             ::sycl::range<1>(localSize * filter_config.max_triplets_per_spM),
             h);

         SeedSelect kernel(
             filter_config, spacepoints_view, internal_sp_view,
             doublet_counter_container_view, triplet_counter_container_view,
             triplet_container_view, seed_container_view, localMem);

         h.parallel_for<class seed_select_kernel>(seedSelectNdRange, kernel);
     }).wait_and_throw();
}

}  // namespace sycl
}  // namespace traccc
