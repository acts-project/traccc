/** TRACCC library, part of the ACTS project (R&D line)
 *
 * (c) 2021-2022 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

// SYCL library include(s).
#include "traccc/sycl/seeding/seed_finding.hpp"

// SYCL library include(s).
#include "../utils/get_queue.hpp"
#include "seed_selecting.hpp"
#include "sycl_helper.hpp"
#include "traccc/sycl/utils/calculate1DimNdRange.hpp"
#include "triplet_finding.hpp"
#include "weight_updating.hpp"

// Project include(s).
#include "traccc/device/get_prefix_sum.hpp"
#include "traccc/edm/device/doublet_counter.hpp"
#include "traccc/seeding/detail/doublet.hpp"
#include "traccc/seeding/detail/triplet.hpp"
#include "traccc/seeding/device/count_doublets.hpp"
#include "traccc/seeding/device/count_triplets.hpp"
#include "traccc/seeding/device/find_doublets.hpp"
#include "traccc/seeding/device/make_doublet_buffers.hpp"
#include "traccc/seeding/device/make_doublet_counter_buffer.hpp"
#include "traccc/seeding/device/make_triplet_counter_buffer.hpp"

// VecMem include(s).
#include "vecmem/utils/sycl/copy.hpp"

namespace traccc::sycl {
namespace kernels {

/// Class identifying the kernel running @c traccc::device::count_doublets
class count_doublets;

/// Class identifying the kernel running @c traccc::device::find_doublets
class find_doublets;

/// Class identifying the kernel running @c traccc::device::count_triplets
class count_triplets;

}  // namespace kernels

seed_finding::seed_finding(const seedfinder_config& config,
                           const traccc::memory_resource& mr,
                           queue_wrapper queue)
    : m_seedfinder_config(config), m_mr(mr), m_queue(queue) {

    // Initialize m_copy ptr based on memory resources that were given
    if (mr.host) {
        m_copy = std::make_unique<vecmem::sycl::copy>(queue.queue());
    } else {
        m_copy = std::make_unique<vecmem::copy>();
    }
}

vecmem::data::vector_buffer<seed> seed_finding::operator()(
    const spacepoint_container_types::const_view& spacepoints_view,
    const sp_grid_const_view& g2_view) const {
    // Get the sizes from the grid view
    auto grid_sizes = m_copy->get_sizes(g2_view._data_view);

    return this->operator()(spacepoints_view, g2_view, grid_sizes);
}

vecmem::data::vector_buffer<seed> seed_finding::operator()(
    const spacepoint_container_types::buffer& spacepoints_buffer,
    const sp_grid_buffer& g2_buffer) const {
    // Get the sizes from the grid buffer
    auto grid_sizes = m_copy->get_sizes(g2_buffer._buffer);

    return this->operator()(spacepoints_buffer, g2_buffer, grid_sizes);
}

vecmem::data::vector_buffer<seed> seed_finding::operator()(
    const spacepoint_container_types::const_view& spacepoints_view,
    const sp_grid_const_view& g2_view,
    const std::vector<unsigned int>& grid_sizes) const {

    // Get the prefix sum for the spacepoint grid using buffer.
    const device::prefix_sum_t sp_grid_prefix_sum = device::get_prefix_sum(
        grid_sizes, (m_mr.host ? *(m_mr.host) : m_mr.main));

    // Set up the doublet counter buffer.
    device::doublet_counter_container_types::buffer doublet_counter_buffer =
        device::make_doublet_counter_buffer(grid_sizes, *m_copy, m_mr.main,
                                            m_mr.host);

    // Set up the buffer of the prefix sum and its view
    vecmem::data::vector_buffer<device::prefix_sum_element_t>
        sp_grid_prefix_sum_buff(sp_grid_prefix_sum.size(), m_mr.main);
    m_copy->setup(sp_grid_prefix_sum_buff);
    (*m_copy)(vecmem::get_data(sp_grid_prefix_sum), sp_grid_prefix_sum_buff);
    vecmem::data::vector_view<device::prefix_sum_element_t>
        sp_grid_prefix_sum_view = sp_grid_prefix_sum_buff;

    // Calculate the range to run the doublet counting for.
    static constexpr unsigned int doubletCountLocalSize = 32 * 2;
    auto doubletCountRange = traccc::sycl::calculate1DimNdRange(
        sp_grid_prefix_sum.size(), doubletCountLocalSize);

    // Count the number of doublets that we need to produce.
    device::doublet_counter_container_types::view doublet_counter_view =
        doublet_counter_buffer;
    details::get_queue(m_queue)
        .submit([&](::sycl::handler& h) {
            h.parallel_for<kernels::count_doublets>(
                doubletCountRange,
                [config = m_seedfinder_config, g2_view, sp_grid_prefix_sum_view,
                 doublet_counter_view](::sycl::nd_item<1> item) {
                    device::count_doublets(item.get_global_linear_id(), config,
                                           g2_view, sp_grid_prefix_sum_view,
                                           doublet_counter_view);
                });
        })
        .wait_and_throw();

    // Get the summary values per bin.
    vecmem::vector<device::doublet_counter_header> doublet_counts(
        m_mr.host ? m_mr.host : &(m_mr.main));
    (*m_copy)(doublet_counter_buffer.headers, doublet_counts);

    // Set up the doublet buffers.
    device::doublet_buffer_pair doublet_buffers = device::make_doublet_buffers(
        doublet_counter_buffer, *m_copy, m_mr.main, m_mr.host);

    // Get the prefix sum for the doublet counter buffer.
    const device::prefix_sum_t doublet_prefix_sum =
        device::get_prefix_sum(doublet_counter_buffer.items,
                               (m_mr.host ? *(m_mr.host) : m_mr.main), *m_copy);

    // Set up the buffer of the prefix sum and its view
    vecmem::data::vector_buffer<device::prefix_sum_element_t>
        doublet_prefix_sum_buff(doublet_prefix_sum.size(), m_mr.main);
    m_copy->setup(doublet_prefix_sum_buff);
    (*m_copy)(vecmem::get_data(doublet_prefix_sum), doublet_prefix_sum_buff);
    vecmem::data::vector_view<device::prefix_sum_element_t>
        doublet_prefix_sum_view = doublet_prefix_sum_buff;

    // Calculate the range to run the doublet finding for.
    static constexpr unsigned int doubletFindLocalSize = 32 * 2;
    auto doubletFindRange = traccc::sycl::calculate1DimNdRange(
        doublet_prefix_sum.size(), doubletFindLocalSize);

    // Find all of the spacepoint doublets.
    doublet_container_view mb_view = doublet_buffers.middleBottom;
    doublet_container_view mt_view = doublet_buffers.middleTop;
    details::get_queue(m_queue)
        .submit([&](::sycl::handler& h) {
            h.parallel_for<kernels::find_doublets>(
                doubletFindRange,
                [config = m_seedfinder_config, g2_view, doublet_counter_view,
                 doublet_prefix_sum_view, mb_view,
                 mt_view](::sycl::nd_item<1> item) {
                    device::find_doublets(item.get_global_linear_id(), config,
                                          g2_view, doublet_counter_view,
                                          doublet_prefix_sum_view, mb_view,
                                          mt_view);
                });
        })
        .wait_and_throw();

    // The number of bins.
    unsigned int nbins = g2_view._data_view.m_size;

    vecmem::vector<doublet_per_bin> mb_headers(m_mr.host ? m_mr.host
                                                         : &(m_mr.main));
    (*m_copy)(doublet_buffers.middleBottom.headers, mb_headers);

    std::vector<std::size_t> mb_buffer_sizes(doublet_counts.size());
    std::transform(
        doublet_counts.begin(), doublet_counts.end(), mb_buffer_sizes.begin(),
        [](const device::doublet_counter_header& dc) { return dc.m_nMidBot; });

    // Get the prefix sum for the midBot doublets using buffer.
    const device::prefix_sum_t mb_prefix_sum =
        device::get_prefix_sum(doublet_buffers.middleBottom.items,
                               (m_mr.host ? *(m_mr.host) : m_mr.main), *m_copy);

    // Set up the triplet counter buffer and its view
    device::triplet_counter_container_types::buffer triplet_counter_buffer =
        device::make_triplet_counter_buffer(mb_buffer_sizes, *m_copy, m_mr.main,
                                            m_mr.host);

    device::triplet_counter_container_types::view triplet_counter_view =
        triplet_counter_buffer;

    // Set up the buffer of the prefix sum and its view
    vecmem::data::vector_buffer<device::prefix_sum_element_t>
        mb_prefix_sum_buff(mb_prefix_sum.size(), m_mr.main);
    m_copy->setup(mb_prefix_sum_buff);
    (*m_copy)(vecmem::get_data(mb_prefix_sum), mb_prefix_sum_buff);
    vecmem::data::vector_view<device::prefix_sum_element_t> mb_prefix_sum_view =
        mb_prefix_sum_buff;

    // Calculate the range to run the triplet counting for.
    static constexpr unsigned int tripletCountLocalSize = 32 * 2;
    auto tripletCountRange = traccc::sycl::calculate1DimNdRange(
        mb_prefix_sum.size(), tripletCountLocalSize);

    // Count the number of triplets that we need to produce.
    details::get_queue(m_queue)
        .submit([&](::sycl::handler& h) {
            h.parallel_for<kernels::count_triplets>(
                tripletCountRange,
                [config = m_seedfinder_config, g2_view, doublet_counter_view,
                 mb_prefix_sum_view, mb_view, mt_view,
                 triplet_counter_view](::sycl::nd_item<1> item) {
                    device::count_triplets(item.get_global_linear_id(), config,
                                           g2_view, doublet_counter_view,
                                           mb_prefix_sum_view, mb_view, mt_view,
                                           triplet_counter_view);
                });
        })
        .wait_and_throw();

    // Take header of the triplet counter container buffer into host
    vecmem::vector<device::triplet_counter_header> tcc_headers(
        m_mr.host ? m_mr.host : &(m_mr.main));
    (*m_copy)(triplet_counter_buffer.headers, tcc_headers);

    // Fill the size vector for triplet container
    std::vector<size_t> n_triplets_per_bin;
    n_triplets_per_bin.reserve(nbins);
    for (const auto& h : tcc_headers) {
        n_triplets_per_bin.push_back(h.m_nTriplets);
    }

    // Create triplet container buffer
    triplet_container_buffer tc_buffer{
        {nbins, m_mr.main}, {n_triplets_per_bin, m_mr.main, m_mr.host}};
    m_copy->setup(tc_buffer.headers);
    m_copy->setup(tc_buffer.items);

    // triplet finding
    triplet_finding(m_seedfinder_config, m_seedfilter_config, tcc_headers,
                    g2_view, doublet_counter_view, mb_view, mt_view,
                    triplet_counter_buffer, tc_buffer, m_queue);

    // Take header of the triplet container buffer into host
    vecmem::vector<triplet_per_bin> tc_headers(m_mr.host ? m_mr.host
                                                         : &(m_mr.main));
    (*m_copy)(tc_buffer.headers, tc_headers);

    // weight updating
    weight_updating(m_seedfilter_config, tc_headers, g2_view,
                    triplet_counter_buffer, tc_buffer, m_queue);

    // Get the number of seeds (triplets)
    auto n_triplets = std::accumulate(n_triplets_per_bin.begin(),
                                      n_triplets_per_bin.end(), 0);

    vecmem::data::vector_buffer<seed> seed_buffer(n_triplets, 0, m_mr.main);
    m_copy->setup(seed_buffer);

    // seed selecting
    seed_selecting(m_seedfilter_config, doublet_counts, spacepoints_view,
                   g2_view, doublet_counter_view, triplet_counter_buffer,
                   tc_buffer, seed_buffer, m_queue);

    return seed_buffer;
}

}  // namespace traccc::sycl
