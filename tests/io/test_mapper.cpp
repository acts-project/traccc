/** TRACCC library, part of the ACTS project (R&D line)
 *
 * (c) 2022 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

// Project include(s).
#include "traccc/io/mapper.hpp"

// VecMem include(s).
#include <vecmem/memory/host_memory_resource.hpp>

// GTest include(s).
#include <gtest/gtest.h>

std::size_t event = 0;

std::string detector_file = "/tml_detector/trackml-detector.csv";
std::string digi_config_file =
    "/tml_detector/default-geometric-config-generic.json";
std::string hits_dir = "../tests/io/mock_data/";
std::string cells_dir = "../tests/io/mock_data/";
std::string particles_dir = "../tests/io/mock_data/";

/***
 * Mock data test
 *
 * Mock data consists of three particles each of which has one hit
 *
 * first particle: one hit, three cells
 * second particle: one hit, four cells
 * thrid particle: one hit, three cells
 *
 * [ ] [1] [ ] [ ] [ ] [ ] [ ] [ ]
 * [1][1,2][2] [ ] [ ] [ ] [ ] [ ]
 * [ ] [2] [2] [ ] [ ] [ ] [ ] [ ]
 * [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ]
 * [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ]
 * [ ] [ ] [ ] [ ] [ ] [3] [3] [3]
 * [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ]
 * [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ]
 *
 * Current traccc's CCA algorithm will make two clusters
 *
 * first cluster is a set of cells generated by 1st and 2nd particles
 * second cluster is a set of cells generated by 3rd particle
 *
 */

// Test generate_particle_map function
TEST(mappper, particle_map) {
    auto p_map = traccc::generate_particle_map(event, particles_dir);

    EXPECT_EQ(p_map.size(), 3);

    std::size_t pid0 = 4503599644147712;
    std::size_t pid1 = 4503599660924928;
    std::size_t pid2 = 4503599744811008;

    EXPECT_EQ(p_map[pid0].pos,
              traccc::vector3({-0.0120002991, -9.48547313e-05, -15.1165705}));

    EXPECT_EQ(p_map[pid1].pos, traccc::vector3({-0.4, -0.23412, -100.}));

    EXPECT_EQ(p_map[pid2].pos, traccc::vector3({-1999., -9.231, 23425.}));
}

// Test generate_hit_particle_map function
TEST(mappper, hit_particle_map) {
    auto h_p_map =
        traccc::generate_hit_particle_map(event, hits_dir, particles_dir);

    EXPECT_EQ(h_p_map.size(), 3);

    traccc::spacepoint sp0;
    sp0.global = traccc::point3{39.2037048, 0.352969825, -1502.5};

    traccc::spacepoint sp1;
    sp1.global = traccc::point3{31.5048428, 5.16000509, -1502.5};

    traccc::spacepoint sp2;
    sp2.global = traccc::point3{90.4015808, 0.7420941, -1502.5};

    EXPECT_EQ(h_p_map[sp0].particle_id, 4503599644147712);
    EXPECT_EQ(h_p_map[sp1].particle_id, 4503599660924928);
    EXPECT_EQ(h_p_map[sp2].particle_id, 4503599744811008);
}

// Test generate_hit_map function
TEST(mappper, hit_map) {
    auto h_map = traccc::generate_hit_map(event, hits_dir);

    EXPECT_EQ(h_map.size(), 3);
    traccc::point3 p0{39.2037048, 0.352969825, -1502.5};
    traccc::point3 p1{31.5048428, 5.16000509, -1502.5};
    traccc::point3 p2{90.4015808, 0.7420941, -1502.5};
    EXPECT_EQ(h_map[0].global, p0);
    EXPECT_EQ(h_map[1].global, p1);
    EXPECT_EQ(h_map[2].global, p2);
}

// Test generate_hit_cell_map function
TEST(mappper, hit_cell_map) {
    auto h_c_map = traccc::generate_hit_cell_map(event, cells_dir, hits_dir);

    EXPECT_EQ(h_c_map.size(), 3);

    traccc::spacepoint sp0;
    sp0.global = traccc::point3{39.2037048, 0.352969825, -1502.5};

    traccc::spacepoint sp1;
    sp1.global = traccc::point3{31.5048428, 5.16000509, -1502.5};

    traccc::spacepoint sp2;
    sp2.global = traccc::point3{90.4015808, 0.7420941, -1502.5};

    std::vector<traccc::cell> cells0;
    cells0.push_back({1, 0, 0.0041470062, 0, 0});
    cells0.push_back({0, 1, 0.00306466641, 0, 0});
    cells0.push_back({1, 1, 0.00868905429, 0, 0});

    std::vector<traccc::cell> cells1;
    cells1.push_back({1, 1, 0.00886478275, 0, 0});
    cells1.push_back({1, 2, 0.00580428448, 0, 0});
    cells1.push_back({2, 1, 0.0016894876, 0, 0});
    cells1.push_back({2, 2, 0.00199076766, 0, 0});

    std::vector<traccc::cell> cells2;
    cells2.push_back({5, 5, 0.00632160669, 0, 0});
    cells2.push_back({5, 6, 0.00911649223, 0, 0});
    cells2.push_back({5, 7, 0.00518329488, 0, 0});

    EXPECT_EQ(h_c_map[sp0], cells0);
    EXPECT_EQ(h_c_map[sp1], cells1);
    EXPECT_EQ(h_c_map[sp2], cells2);
}

// Test generate_cell_particle_map function
TEST(mappper, cell_particle_map) {

    auto c_p_map = traccc::generate_cell_particle_map(event, cells_dir,
                                                      hits_dir, particles_dir);

    traccc::cell cell0{1, 0, 0.0041470062, 0, 0};
    traccc::cell cell1{0, 1, 0.00306466641, 0, 0};
    traccc::cell cell2{1, 1, 0.00868905429, 0, 0};
    traccc::cell cell3{1, 1, 0.00886478275, 0, 0};
    traccc::cell cell4{1, 2, 0.00580428448, 0, 0};
    traccc::cell cell5{2, 1, 0.0016894876, 0, 0};
    traccc::cell cell6{2, 2, 0.00199076766, 0, 0};
    traccc::cell cell7{5, 5, 0.00632160669, 0, 0};
    traccc::cell cell8{5, 6, 0.00911649223, 0, 0};
    traccc::cell cell9{5, 7, 0.00518329488, 0, 0};

    EXPECT_EQ(c_p_map[cell0].particle_id, 4503599644147712);
    EXPECT_EQ(c_p_map[cell1].particle_id, 4503599644147712);
    EXPECT_EQ(c_p_map[cell2].particle_id, 4503599644147712);
    EXPECT_EQ(c_p_map[cell3].particle_id, 4503599660924928);
    EXPECT_EQ(c_p_map[cell4].particle_id, 4503599660924928);
    EXPECT_EQ(c_p_map[cell5].particle_id, 4503599660924928);
    EXPECT_EQ(c_p_map[cell6].particle_id, 4503599660924928);
    EXPECT_EQ(c_p_map[cell7].particle_id, 4503599744811008);
    EXPECT_EQ(c_p_map[cell8].particle_id, 4503599744811008);
    EXPECT_EQ(c_p_map[cell9].particle_id, 4503599744811008);
}

// Test generate_measurement_cell_map function
TEST(mappper, measurement_cell_map) {

    auto compare_cells = [](vecmem::vector<traccc::cell>& cells1,
                            vecmem::vector<traccc::cell>& cells2) {
        std::sort(cells1.begin(), cells1.end());
        std::sort(cells2.begin(), cells2.end());

        EXPECT_EQ(cells1, cells2);
    };

    vecmem::host_memory_resource resource;

    auto m_c_map_pair = traccc::generate_measurement_cell_map(
        event, detector_file, digi_config_file, cells_dir, resource);
    auto m_c_map = std::get<0>(m_c_map_pair);

    vecmem::vector<traccc::cell> cells0;
    cells0.push_back({1, 0, 0.0041470062, 0, 0});
    cells0.push_back({0, 1, 0.00306466641, 0, 0});
    cells0.push_back({1, 1, 0.00868905429, 0, 0});
    cells0.push_back({1, 1, 0.00886478275, 0, 0});
    cells0.push_back({1, 2, 0.00580428448, 0, 0});
    cells0.push_back({2, 1, 0.0016894876, 0, 0});
    cells0.push_back({2, 2, 0.00199076766, 0, 0});

    vecmem::vector<traccc::cell> cells1;
    cells1.push_back({5, 5, 0.00632160669, 0, 0});
    cells1.push_back({5, 6, 0.00911649223, 0, 0});
    cells1.push_back({5, 7, 0.00518329488, 0, 0});

    EXPECT_EQ(m_c_map.size(), 2);

    bool has_first_cluster = false;
    bool has_second_cluster = false;

    for (auto [meas, cells] : m_c_map) {

        // first cluster with seven cells
        if (cells.size() == 7) {
            compare_cells(cells, cells0);
            has_first_cluster = true;
        }

        // second cluster with three cells
        else if (cells.size() == 3) {
            compare_cells(cells, cells1);
            has_second_cluster = true;
        }
    }

    EXPECT_EQ(has_first_cluster, true);
    EXPECT_EQ(has_second_cluster, true);
}

// Test the first generate_measurement_particle_map function
TEST(mappper, measurement_particle_map_with_clusterization) {

    vecmem::host_memory_resource mr;

    auto m_p_map = traccc::generate_measurement_particle_map(
        event, detector_file, digi_config_file, cells_dir, hits_dir,
        particles_dir, mr);

    // There are two measurements (or clusters)
    EXPECT_EQ(m_p_map.size(), 2);

    bool has_first_cluster = false;
    bool has_second_cluster = false;

    bool has_first_particle = false;
    bool has_second_particle = false;
    bool has_third_particle = false;

    for (auto const& [meas, ptcs] : m_p_map) {

        // first measurement (or cluster) is contributed by 1st and 2nd
        // particles
        if (ptcs.size() == 2) {
            for (auto const& [ptc, count] : ptcs) {
                if (ptc.particle_id == 4503599644147712) {
                    // number of cells from 1st particle
                    EXPECT_EQ(count, 3);
                    has_first_particle = true;
                } else if (ptc.particle_id == 4503599660924928) {
                    // number of cells from 2nd particle
                    EXPECT_EQ(count, 4);
                    has_second_particle = true;
                }
            }

            has_first_cluster = true;
        }

        // second measurement (or cluster) is contributed by 3rd particle
        else if (ptcs.size() == 1) {
            for (auto const& [ptc, count] : ptcs) {
                if (ptc.particle_id == 4503599744811008) {
                    // number of cells from 3rd particle
                    EXPECT_EQ(count, 3);
                    has_third_particle = true;
                }
            }

            has_second_cluster = true;
        }
    }

    EXPECT_EQ(has_first_cluster, true);
    EXPECT_EQ(has_second_cluster, true);
    EXPECT_EQ(has_first_particle, true);
    EXPECT_EQ(has_second_particle, true);
    EXPECT_EQ(has_third_particle, true);
}

// Test the second generate_measurement_particle_map function
TEST(mappper, measurement_particle_map_without_clusterization) {

    vecmem::host_memory_resource mr;

    auto m_p_map = traccc::generate_measurement_particle_map(
        event, detector_file, hits_dir, particles_dir, mr);

    // Without clusterization, there are three measurements each of which is
    // from each particle
    EXPECT_EQ(m_p_map.size(), 3);

    bool has_first_particle = false;
    bool has_second_particle = false;
    bool has_third_particle = false;

    for (auto const& [meas, ptcs] : m_p_map) {
        // Without clusterization, there is only one contributing particle for
        // measurement
        EXPECT_EQ(ptcs.size(), 1);

        for (auto const& [ptc, count] : ptcs) {

            if (ptc.particle_id == 4503599644147712) {
                EXPECT_EQ(count, 1);
                has_first_particle = true;
            } else if (ptc.particle_id == 4503599660924928) {
                EXPECT_EQ(count, 1);
                has_second_particle = true;
            } else if (ptc.particle_id == 4503599744811008) {
                EXPECT_EQ(count, 1);
                has_third_particle = true;
            }
        }
    }

    EXPECT_EQ(has_first_particle, true);
    EXPECT_EQ(has_second_particle, true);
    EXPECT_EQ(has_third_particle, true);
}
