/** TRACCC library, part of the ACTS project (R&D line)
 *
 * (c) 2022-2024 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

// Project include(s).
#include "traccc/geometry/silicon_detector_description.hpp"
#include "traccc/io/mapper.hpp"
#include "traccc/io/read_detector_description.hpp"

// VecMem include(s).
#include <vecmem/memory/host_memory_resource.hpp>

// GTest include(s).
#include <gtest/gtest.h>

// System include(s).
#include <cmath>

static const std::size_t event = 0;

static const std::string detector_file = "tml_detector/trackml-detector.csv";
static const std::string digi_config_file =
    "tml_detector/default-geometric-config-generic.json";
static const std::string hits_dir = TRACCC_TEST_IO_MOCK_DATA_DIR;
static const std::string cells_dir = TRACCC_TEST_IO_MOCK_DATA_DIR;
static const std::string particles_dir = TRACCC_TEST_IO_MOCK_DATA_DIR;

/// Helper lambda for comparing two cell collections
///
/// The cell order in the two containers doesn't necessarily have to match.
/// So the code checks that:
///  - every cell from the first container is found in the second container;
///  - every cell from the second container is associated to exactly one cell
///    from the first container.
///
static auto compare_cells =
    [](const traccc::edm::silicon_cell_collection::host& c1,
       const traccc::edm::silicon_cell_collection::host& c2) {
        EXPECT_EQ(c1.size(), c2.size());

        std::vector<int> c2_find_count(c2.size(), 0);
        for (std::size_t i = 0; i < c1.size(); ++i) {
            bool found = false;
            for (std::size_t j = 0; j < c2.size(); ++j) {
                if (c1.channel0().at(i) == c2.channel0().at(j) &&
                    c1.channel1().at(i) == c2.channel1().at(j) &&
                    (std::abs(c1.activation().at(i) - c2.activation().at(j)) <
                     0.0001f) &&
                    (std::abs(c1.time().at(i) - c2.time().at(j)) < 0.0001f) &&
                    c1.module_index().at(i) == c2.module_index().at(j)) {
                    found = true;
                    c2_find_count[j]++;
                    break;
                }
            }
            EXPECT_TRUE(found);
        }
        EXPECT_EQ(c2_find_count, std::vector<int>(c2.size(), 1));
    };

/***
 * Mock data test
 *
 * Mock data consists of three particles each of which has one hit
 *
 * first particle: one hit, three cells
 * second particle: one hit, four cells
 * thrid particle: one hit, three cells
 *
 * [ ] [1] [ ] [ ] [ ] [ ] [ ] [ ]
 * [1][1,2][2] [ ] [ ] [ ] [ ] [ ]
 * [ ] [2] [2] [ ] [ ] [ ] [ ] [ ]
 * [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ]
 * [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ]
 * [ ] [ ] [ ] [ ] [ ] [3] [3] [3]
 * [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ]
 * [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ]
 *
 * Current traccc's CCA algorithm will make two clusters
 *
 * first cluster is a set of cells generated by 1st and 2nd particles
 * second cluster is a set of cells generated by 3rd particle
 *
 */

// Test generate_particle_map function
TEST(mappper, particle_map) {
    auto p_map = traccc::generate_particle_map(event, particles_dir);

    EXPECT_EQ(p_map.size(), 3);

    std::size_t pid0 = 4503599644147712;
    std::size_t pid1 = 4503599660924928;
    std::size_t pid2 = 4503599744811008;

    EXPECT_EQ(
        p_map[pid0].vertex,
        traccc::vector3({-0.0120002991f, -9.48547313e-05f, -15.1165705f}));

    EXPECT_EQ(p_map[pid1].vertex, traccc::vector3({-0.4f, -0.23412f, -100.f}));

    EXPECT_EQ(p_map[pid2].vertex, traccc::vector3({-1999.f, -9.231f, 23425.f}));
}

// Test generate_hit_particle_map function
TEST(mappper, hit_particle_map) {
    auto h_p_map =
        traccc::generate_hit_particle_map(event, hits_dir, particles_dir);

    EXPECT_EQ(h_p_map.size(), 3);

    traccc::spacepoint sp0;
    sp0.global = traccc::point3{39.2037048f, 0.352969825f, -1502.5f};

    traccc::spacepoint sp1;
    sp1.global = traccc::point3{31.5048428f, 5.16000509f, -1502.5f};

    traccc::spacepoint sp2;
    sp2.global = traccc::point3{90.4015808f, 0.7420941f, -1502.5f};

    EXPECT_EQ(h_p_map[sp0].particle_id, 4503599644147712);
    EXPECT_EQ(h_p_map[sp1].particle_id, 4503599660924928);
    EXPECT_EQ(h_p_map[sp2].particle_id, 4503599744811008);
}

// Test generate_hit_map function
TEST(mappper, hit_map) {
    auto h_map = traccc::generate_hit_map(event, hits_dir);

    EXPECT_EQ(h_map.size(), 3);
    traccc::point3 p0{39.2037048f, 0.352969825f, -1502.5f};
    traccc::point3 p1{31.5048428f, 5.16000509f, -1502.5f};
    traccc::point3 p2{90.4015808f, 0.7420941f, -1502.5f};
    EXPECT_EQ(h_map[0].global, p0);
    EXPECT_EQ(h_map[1].global, p1);
    EXPECT_EQ(h_map[2].global, p2);
}

// Test generate_hit_cell_map function
TEST(mappper, hit_cell_map) {

    vecmem::host_memory_resource resource;
    auto h_c_map =
        traccc::generate_hit_cell_map(event, cells_dir, hits_dir, resource);

    EXPECT_EQ(h_c_map.size(), 3);

    traccc::spacepoint sp0;
    sp0.global = traccc::point3{39.2037048f, 0.352969825f, -1502.5};

    traccc::spacepoint sp1;
    sp1.global = traccc::point3{31.5048428f, 5.16000509f, -1502.5};

    traccc::spacepoint sp2;
    sp2.global = traccc::point3{90.4015808f, 0.7420941f, -1502.5};

    traccc::edm::silicon_cell_collection::host cells0{resource};
    cells0.resize(3);
    cells0.channel0() = {1u, 0u, 1u};
    cells0.channel1() = {0u, 1u, 1u};
    cells0.activation() = {0.0041470062f, 0.00306466641f, 0.00868905429f};
    cells0.time() = {0.f, 0.f, 0.f};
    cells0.module_index() = {0u, 0u, 0u};

    traccc::edm::silicon_cell_collection::host cells1{resource};
    cells1.resize(4);
    cells1.channel0() = {1u, 1u, 2u, 2u};
    cells1.channel1() = {1u, 2u, 1u, 2u};
    cells1.activation() = {0.00886478275f, 0.00580428448f, 0.0016894876f,
                           0.00199076766f};
    cells1.time() = {0.f, 0.f, 0.f, 0.f};
    cells1.module_index() = {0u, 0u, 0u, 0u};

    traccc::edm::silicon_cell_collection::host cells2{resource};
    cells2.resize(3);
    cells2.channel0() = {5u, 5u, 5u};
    cells2.channel1() = {5u, 6u, 7u};
    cells2.activation() = {0.00632160669f, 0.00911649223f, 0.00518329488f};
    cells2.time() = {0.f, 0.f, 0.f};
    cells2.module_index() = {0u, 0u, 0u};

    auto sp0cells = h_c_map.find(sp0);
    ASSERT_NE(sp0cells, h_c_map.end());
    compare_cells(sp0cells->second, cells0);

    auto sp1cells = h_c_map.find(sp1);
    ASSERT_NE(sp1cells, h_c_map.end());
    compare_cells(sp1cells->second, cells1);

    auto sp2cells = h_c_map.find(sp2);
    ASSERT_NE(sp2cells, h_c_map.end());
    compare_cells(sp2cells->second, cells2);
}

// Test generate_cell_particle_map function
TEST(mappper, cell_particle_map) {

    vecmem::host_memory_resource resource;
    auto p_c_map = traccc::generate_particle_cell_map(
        event, cells_dir, hits_dir, particles_dir, resource);

    traccc::particle p1{4503599644147712, 0, 0, {}, 0.f, {}, 0.f, 0.f};
    traccc::edm::silicon_cell_collection::host cells1{resource};
    cells1.resize(3);
    cells1.channel0() = {1u, 0u, 1u};
    cells1.channel1() = {0u, 1u, 1u};
    cells1.activation() = {0.0041470062f, 0.00306466641f, 0.00868905429f};
    cells1.time() = {0.f, 0.f, 0.f};
    cells1.module_index() = {0u, 0u, 0u};

    auto p1cells = p_c_map.find(p1);
    ASSERT_NE(p1cells, p_c_map.end());
    compare_cells(p1cells->second, cells1);

    traccc::particle p2{4503599660924928, 0, 0, {}, 0.f, {}, 0.f, 0.f};
    traccc::edm::silicon_cell_collection::host cells2{resource};
    cells2.resize(4);
    cells2.channel0() = {1u, 1u, 2u, 2u};
    cells2.channel1() = {1u, 2u, 1u, 2u};
    cells2.activation() = {0.00886478275f, 0.00580428448f, 0.0016894876f,
                           0.00199076766f};
    cells2.time() = {0.f, 0.f, 0.f, 0.f};
    cells2.module_index() = {0u, 0u, 0u, 0u};

    auto p2cells = p_c_map.find(p2);
    ASSERT_NE(p2cells, p_c_map.end());
    compare_cells(p2cells->second, cells2);

    traccc::particle p3{4503599744811008, 0, 0, {}, 0.f, {}, 0.f, 0.f};
    traccc::edm::silicon_cell_collection::host cells3{resource};
    cells3.resize(3);
    cells3.channel0() = {5u, 5u, 5u};
    cells3.channel1() = {5u, 6u, 7u};
    cells3.activation() = {0.00632160669f, 0.00911649223f, 0.00518329488f};
    cells3.time() = {0.f, 0.f, 0.f};
    cells3.module_index() = {0u, 0u, 0u};

    auto p3cells = p_c_map.find(p3);
    ASSERT_NE(p3cells, p_c_map.end());
    compare_cells(p3cells->second, cells3);
}

// Test generate_measurement_cell_map function
TEST(mappper, measurement_cell_map) {

    vecmem::host_memory_resource resource;

    traccc::silicon_detector_description::host dd{resource};
    traccc::io::read_detector_description(dd, detector_file, digi_config_file,
                                          traccc::data_format::csv);

    auto m_c_map =
        traccc::generate_measurement_cell_map(event, cells_dir, dd, resource);

    // The module that the cells of event 0 belong to, happens to be this one.
    constexpr traccc::cell::link_type module_link = 12465;

    traccc::edm::silicon_cell_collection::host cells0{resource};
    cells0.resize(7);
    cells0.channel0() = {1u, 0u, 1u, 1u, 1u, 2u, 2u};
    cells0.channel1() = {0u, 1u, 1u, 1u, 2u, 1u, 2u};
    cells0.activation() = {0.0041470062f,  0.00306466641f, 0.00868905429f,
                           0.00886478275f, 0.00580428448f, 0.0016894876f,
                           0.00199076766f};
    cells0.time() = {0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f};
    cells0.module_index() = {module_link, module_link, module_link, module_link,
                             module_link, module_link, module_link};

    traccc::edm::silicon_cell_collection::host cells1{resource};
    cells1.resize(3);
    cells1.channel0() = {5u, 5u, 5u};
    cells1.channel1() = {5u, 6u, 7u};
    cells1.activation() = {0.00632160669f, 0.00911649223f, 0.00518329488f};
    cells1.time() = {0.f, 0.f, 0.f};
    cells1.module_index() = {module_link, module_link, module_link};

    EXPECT_EQ(m_c_map.size(), 2);

    bool has_first_cluster = false;
    bool has_second_cluster = false;

    for (auto [meas, cells] : m_c_map) {

        // first cluster with seven cells
        if (cells.size() == 7) {
            compare_cells(cells, cells0);
            has_first_cluster = true;
        }

        // second cluster with three cells
        else if (cells.size() == 3) {
            compare_cells(cells, cells1);
            has_second_cluster = true;
        }
    }

    EXPECT_TRUE(has_first_cluster);
    EXPECT_TRUE(has_second_cluster);
}

// Test the first generate_measurement_particle_map function
TEST(mappper, measurement_particle_map_with_clusterization) {

    vecmem::host_memory_resource mr;

    traccc::silicon_detector_description::host dd{mr};
    traccc::io::read_detector_description(dd, detector_file, digi_config_file,
                                          traccc::data_format::csv);

    auto m_p_map = traccc::generate_measurement_particle_map(
        event, cells_dir, hits_dir, particles_dir, dd, mr);

    // There are two measurements (or clusters)
    EXPECT_EQ(m_p_map.size(), 2);

    bool has_first_cluster = false;
    bool has_second_cluster = false;

    bool has_first_particle = false;
    bool has_second_particle = false;
    bool has_third_particle = false;

    for (auto const& [meas, ptcs] : m_p_map) {

        // first measurement (or cluster) is contributed by 1st and 2nd
        // particles
        if (ptcs.size() == 2) {
            for (auto const& [ptc, count] : ptcs) {
                if (ptc.particle_id == 4503599644147712) {
                    // number of cells from 1st particle
                    EXPECT_EQ(count, 3);
                    has_first_particle = true;
                } else if (ptc.particle_id == 4503599660924928) {
                    // number of cells from 2nd particle
                    EXPECT_EQ(count, 4);
                    has_second_particle = true;
                }
            }

            has_first_cluster = true;
        }

        // second measurement (or cluster) is contributed by 3rd particle
        else if (ptcs.size() == 1) {
            for (auto const& [ptc, count] : ptcs) {
                if (ptc.particle_id == 4503599744811008) {
                    // number of cells from 3rd particle
                    EXPECT_EQ(count, 3);
                    has_third_particle = true;
                }
            }

            has_second_cluster = true;
        }
    }

    EXPECT_EQ(has_first_cluster, true);
    EXPECT_EQ(has_second_cluster, true);
    EXPECT_EQ(has_first_particle, true);
    EXPECT_EQ(has_second_particle, true);
    EXPECT_EQ(has_third_particle, true);
}

// Test the second generate_measurement_particle_map function
TEST(mappper, measurement_particle_map_without_clusterization) {

    vecmem::host_memory_resource mr;

    traccc::silicon_detector_description::host dd{mr};
    traccc::io::read_detector_description(dd, detector_file, digi_config_file,
                                          traccc::data_format::csv);

    auto m_p_map = traccc::generate_measurement_particle_map(
        event, hits_dir, particles_dir, dd, mr);

    // Without clusterization, there are three measurements each of which is
    // from each particle
    EXPECT_EQ(m_p_map.size(), 3);

    bool has_first_particle = false;
    bool has_second_particle = false;
    bool has_third_particle = false;

    for (auto const& [meas, ptcs] : m_p_map) {
        // Without clusterization, there is only one contributing particle for
        // measurement
        EXPECT_EQ(ptcs.size(), 1);

        for (auto const& [ptc, count] : ptcs) {

            if (ptc.particle_id == 4503599644147712) {
                EXPECT_EQ(count, 1);
                has_first_particle = true;
            } else if (ptc.particle_id == 4503599660924928) {
                EXPECT_EQ(count, 1);
                has_second_particle = true;
            } else if (ptc.particle_id == 4503599744811008) {
                EXPECT_EQ(count, 1);
                has_third_particle = true;
            }
        }
    }

    EXPECT_EQ(has_first_particle, true);
    EXPECT_EQ(has_second_particle, true);
    EXPECT_EQ(has_third_particle, true);
}
