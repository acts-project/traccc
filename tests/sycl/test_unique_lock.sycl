/**
 * traccc library, part of the ACTS project (R&D line)
 *
 * (c) 2024 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

#include <gtest/gtest.h>

#include <CL/sycl.hpp>
#include <vecmem/memory/sycl/shared_memory_resource.hpp>
#include <vecmem/memory/unique_ptr.hpp>

#include "traccc/device/mutex.hpp"
#include "traccc/device/unique_lock.hpp"

TEST(SYCLUniqueLock, MassAdditionKernelTryLock) {
    vecmem::sycl::shared_memory_resource mr;
    cl::sycl::queue queue;

    vecmem::unique_alloc_ptr<uint32_t> out =
        vecmem::make_unique_alloc<uint32_t>(mr);
    vecmem::unique_alloc_ptr<uint32_t> lock =
        vecmem::make_unique_alloc<uint32_t>(mr);

    queue.memset(lock.get(), 0, sizeof(uint32_t)).wait_and_throw();

    uint32_t n_blocks = 262144;
    uint32_t n_threads = 32;

    cl::sycl::nd_range test_range(cl::sycl::range<1>(n_blocks * n_threads),
                                  cl::sycl::range<1>(n_threads));

    queue
        .submit([&, out = out.get(), _lock = lock.get()](cl::sycl::handler &h) {
            h.parallel_for<class MassAdditionTryLockTest>(
                test_range, [=](cl::sycl::nd_item<1> item) {
                    traccc::device::mutex m(*_lock);

                    if (item.get_local_id() == 0) {
                        traccc::device::unique_lock lock(m, std::try_to_lock);

                        if (!lock.owns_lock()) {
                            lock.lock();
                        }

                        uint32_t tmp = *out;
                        tmp += 1;
                        *out = tmp;
                    }
                });
        })
        .wait_and_throw();

    EXPECT_EQ(n_blocks, *out.get());
}

TEST(SYCLUniqueLock, MassAdditionKernelDeferLock) {
    vecmem::sycl::shared_memory_resource mr;
    cl::sycl::queue queue;

    vecmem::unique_alloc_ptr<uint32_t> out =
        vecmem::make_unique_alloc<uint32_t>(mr);
    vecmem::unique_alloc_ptr<uint32_t> lock =
        vecmem::make_unique_alloc<uint32_t>(mr);

    queue.memset(lock.get(), 0, sizeof(uint32_t)).wait_and_throw();

    uint32_t n_blocks = 262144;
    uint32_t n_threads = 32;

    cl::sycl::nd_range test_range(cl::sycl::range<1>(n_blocks * n_threads),
                                  cl::sycl::range<1>(n_threads));

    queue
        .submit([&, out = out.get(), _lock = lock.get()](cl::sycl::handler &h) {
            h.parallel_for<class MassAdditionDeferLockTest>(
                test_range, [=](cl::sycl::nd_item<1> item) {
                    traccc::device::mutex m(*_lock);
                    traccc::device::unique_lock lock(m, std::defer_lock);

                    if (item.get_local_id() == 0) {
                        lock.lock();

                        uint32_t tmp = *out;
                        tmp += 1;
                        *out = tmp;
                    }
                });
        })
        .wait_and_throw();

    EXPECT_EQ(n_blocks, *out.get());
}

TEST(SYCLUniqueLock, MassAdditionKernelAdoptLock) {
    vecmem::sycl::shared_memory_resource mr;
    cl::sycl::queue queue;

    vecmem::unique_alloc_ptr<uint32_t> out =
        vecmem::make_unique_alloc<uint32_t>(mr);
    vecmem::unique_alloc_ptr<uint32_t> lock =
        vecmem::make_unique_alloc<uint32_t>(mr);

    queue.memset(lock.get(), 0, sizeof(uint32_t)).wait_and_throw();

    uint32_t n_blocks = 262144;
    uint32_t n_threads = 32;

    cl::sycl::nd_range test_range(cl::sycl::range<1>(n_blocks * n_threads),
                                  cl::sycl::range<1>(n_threads));

    queue
        .submit([&, out = out.get(), _lock = lock.get()](cl::sycl::handler &h) {
            h.parallel_for<class MassAdditionAdoptLockTest>(
                test_range, [=](cl::sycl::nd_item<1> item) {
                    traccc::device::mutex m(*_lock);

                    if (item.get_local_id() == 0) {
                        m.lock();
                        traccc::device::unique_lock lock(m, std::adopt_lock);

                        uint32_t tmp = *out;
                        tmp += 1;
                        *out = tmp;
                    }
                });
        })
        .wait_and_throw();

    EXPECT_EQ(n_blocks, *out.get());
}
